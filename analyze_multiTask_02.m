

% This script contains analysis of the WM, AS, CR, and FL.
% It assumes that the script analyze_preprocessSessions_01.m was run to
% save trialdata from 1 or more sessions containing the tasks

addpath([pwd filesep 'fcn_local'])
% --- --- --- --- --- --- --- ---
% --- cfg for analysis:
% --- --- --- --- --- --- --- ---

cfg = [];
cfg.do_LoadData = 0;
cfg.do_AnalysisBasic = 1;
cfg.do_AnalysisBasicPlot = 0;
cfg.analysisID = {};

cfg.analysisID{end+1} = 'Bard_WM_AS_CR_FL_083'; 
cfg.analysisID{end+1} = 'Frey_WM_AS_CR_FL_083';
cfg.analysisID{end+1} = 'Igor_WM_AS_CR_FL_083'; 
cfg.analysisID{end+1} = 'Reider_WM_AS_CR_FL_083'; 
cfg.analysisID{end+1} = 'Sindri_WM_AS_CR_FL_083'; 
cfg.analysisID{end+1} = 'Wotan_WM_AS_CR_FL_083';


cfg.RESULTFOLDER          = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis';
cfg.RESULTFILE            = 'WM_AS_CR_FL__MultiTask';
iResultFileMetrics = [cfg.RESULTFILE '_Metrics'];
%RESULTFOLDER = [HOME_FOLDER filesep iResultFolder '_MAT']; if ~exist(RESULTFOLDER), mkdir(RESULTFOLDER),end
METRICSFOLDER  = [cfg.RESULTFOLDER '_METRICS']; if ~exist(METRICSFOLDER), mkdir(METRICSFOLDER),end
FIGURE_Folder = [cfg.RESULTFOLDER '_FIG'];    if ~exist(FIGURE_Folder), mkdir(FIGURE_Folder), end

if cfg.do_LoadData==1

res_mt = cell(1, numel(cfg.analysisID));

for iS=1:numel(cfg.analysisID)
% --- folder with preprocecced data
cfg.RESULTFOLDER          = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis';
cfg.RESULTFILE            = 'WM_AS_CR_FL__MultiTask';
if strcmp(cfg.analysisID{iS},'Wotan_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Wotan';
    iSubject                  = 'Wotan';
elseif strcmp(cfg.analysisID{iS},'Frey_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Frey';
    iSubject                  = 'Frey';
elseif strcmp(cfg.analysisID{iS},'Bard_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Bard';
    iSubject                  = 'Bard';
elseif strcmp(cfg.analysisID{iS},'Reider_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Reider';
    iSubject                  = 'Reider';
elseif strcmp(cfg.analysisID{iS},'Igor_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Igor';
    iSubject                  = 'Igor';
elseif strcmp(cfg.analysisID{iS},'Sindri_WM_AS_CR_FL_083')
    cfg.MUSEMATFOLDERNames{1} = '/Users/wenxuan/Documents/MATLAB/Multitasking_analysis/MUSEMAT01_WM_AS_CR_FL_083_Sindri';
    iSubject                  = 'Sindri';
end



% --- --- --- --- --- --- --- ---
% --- The files generated by this script and the folder name for them:
% --- --- --- --- --- --- --- ---
iResultFileMetrics = [cfg.RESULTFILE '_Metrics'];
%RESULTFOLDER = [HOME_FOLDER filesep iResultFolder '_MAT']; if ~exist(RESULTFOLDER), mkdir(RESULTFOLDER),end
METRICSFOLDER  = [cfg.RESULTFOLDER '_METRICS']; if ~exist(METRICSFOLDER), mkdir(METRICSFOLDER),end
FIGURE_Folder = [cfg.RESULTFOLDER '_FIG'];    if ~exist(FIGURE_Folder), mkdir(FIGURE_Folder), end


% --- --- ---
% --- Loading data and organizing them in a mat file
% --- --- ---

    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- collect all preprocessed data files (from those folders specified):
    % --- --- --- --- --- --- --- --- --- --- --- ---
    datasets = {};
    datasetsDIR = {};
    for iRF=1:length(cfg.MUSEMATFOLDERNames)
        DATAFOLDER = [cfg.MUSEMATFOLDERNames{iRF}]; % DATAFOLDER = [pwd filesep cfg.MUSEMATFOLDERNames{iRF}];
        dirinfo = dir(DATAFOLDER);
        if isempty(dirinfo), sprintf('could not open %s\n',DATAFOLDER), return, end
        % check if dir is in d somewhere around here!
        for j=1:length(dirinfo)
            if (dirinfo(j).isdir) | strcmp(dirinfo(j).name(1),'.' ),  continue, end
            if ~isempty(findstr(dirinfo(j).name,'DAT01_'))
                cL = length(datasets) + 1;
                datasetsDIR{cL} = DATAFOLDER;
                datasets{cL} = dirinfo(j).name(1:end-4);
            end
        end
    end

    res_mt{iS} = [];
    res_mt{iS}.dataset = [];
    res_mt{iS}.datafolder = [];
    res_mt{iS}.SubjectID =  [];
    

    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- specify which features to expect for AS:
    % --- --- --- --- --- --- --- --- --- --- --- ---

    res_mt{iS}.nTrials_as = [];
    res_mt{iS}.TrialInBlock_as = [];
    res_mt{iS}.trialID_as = {};
    res_mt{iS}.Pro1Anti2 = [];

    res_mt{iS}.BlockNum_as = [];
    res_mt{iS}.TrialInExperiment_as = [];
    res_mt{iS}.Outcome_as  = [];
    res_mt{iS}.TokenBarValue_as = [];

    res_mt{iS}.Accuracy_as = [];
    res_mt{iS}.ReactionTime_as = [];
    res_mt{iS}.AbortCode_as = [];

    res_mt{iS}.TargetStimIndex_as = [];
    res_mt{iS}.DistractorStimIndices_as = {};

    res_mt{iS}.SpatialCuePos = {};
    res_mt{iS}.TargetStimDisplayPos = {};
    res_mt{iS}.TargetStimChoosePos = {};
    res_mt{iS}.DistractorStimsChoosePos = {};

    res_mt{iS}.AlertCueDelay_Duration = [];
    res_mt{iS}.SpatialCueDelay_Duration = [];
    res_mt{iS}.DisplayTarget_Duration = [];
    res_mt{iS}.Mask_Duration = [];
    res_mt{iS}.PostMaskDelay_Duration = [];
    res_mt{iS}.ITI_as = [];

    
    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- specify which features to expect for CR:
    % --- --- --- --- --- --- --- --- --- --- --- ---

    res_mt{iS}.nTrials_cr  = [];
    res_mt{iS}.TrialCount_InBlock_cr = [];
    res_mt{iS}.TrialCount_InTask_cr = [];
    res_mt{iS}.BlockCount_cr = [];

    res_mt{iS}.CurrentTrialStims = [];
    res_mt{iS}.ChosenObjectCategory = [];
    res_mt{iS}.ObjectIndexAtError = {};
    res_mt{iS}.ChosenObjectIndex = {};

    res_mt{iS}.ChoseCorrectly = [];
    res_mt{iS}.Accuracy_cr = [];
    res_mt{iS}.ReactionTime_cr  = [];
    res_mt{iS}.NumStimInTrial = [];

    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- specify which features to expect for FL:
    % --- --- --- --- --- --- --- --- --- --- --- ---

    res_mt{iS}.nTrials_fl  = [];

    res_mt{iS}.dimensionNums = {};
    res_mt{iS}.dimensionNames = {};
    res_mt{iS}.dimensionNums{1}=1:9;
    res_mt{iS}.dimensionNames{1}={'S01', 'S02', 'S03', 'S04', 'S05', 'S06', 'S07', 'S08', 'S09'};
    res_mt{iS}.dimensionNums{2}=10:18;
    res_mt{iS}.dimensionNames{2}={'P01', 'P02', 'P03', 'P04', 'P05', 'P06', 'P07', 'P08', 'P09'};
    res_mt{iS}.dimensionNums{3}=19:26;
    res_mt{iS}.dimensionNames{3}{1}={'C6070014_6070014', 'C6070059_6070059', 'C6070106_6070106', 'C6070148_6070148', 'C6070194_6070194', 'C6070239_6070239', 'C6070287_6070287', 'C6070335_6070335'};
    res_mt{iS}.dimensionNames{3}{2}={'C7070014_5000000', 'C7070059_5000000', 'C7070106_5000000', 'C7070148_5000000', 'C7070194_5000000', 'C7070240_5000000', 'C7070286_5000000', 'C7070335_5000000'};
    res_mt{iS}.dimensionNums{4}=27:37;
    res_mt{iS}.dimensionNames{4}={'A00_E01', 'A00_E02', 'A00_E03', 'A01_E00', 'A01_E01', 'A01_E02', 'A01_E03', 'A02_E00', 'A02_E01', 'A02_E02', 'A02_E03'};
    res_mt{iS}.ObjectFeatureLabels = [res_mt{iS}.dimensionNames{1} res_mt{iS}.dimensionNames{2} res_mt{iS}.dimensionNames{3}{1} res_mt{iS}.dimensionNames{4}];
    res_mt{iS}.DimensionVector = [zeros(1,length(res_mt{iS}.dimensionNums{1}))+1, zeros(1,length(res_mt{iS}.dimensionNums{2}))+2, zeros(1,length(res_mt{iS}.dimensionNums{3}))+3, zeros(1,length(res_mt{iS}.dimensionNums{4}))+4];

    res_mt{iS}.TrialID_fl = [];
    res_mt{iS}.BlockNum_fl = [];
    res_mt{iS}.BlockLabel_fl = {};
    res_mt{iS}.TrialInBlock_fl = [];
    res_mt{iS}.TrialConditionLabel_fl = [];
    res_mt{iS}.ContextID_fl = [];
    res_mt{iS}.ReactionTime_fl=[];
    res_mt{iS}.ITI_fl=[];
    res_mt{iS}.TrialInExperiment_fl=[];
    res_mt{iS}.TargetFeature_fl = []; %which feature value is assigned highest reward probability
    res_mt{iS}.CorrectObject_fl = []; %Which object had the target feature
    res_mt{iS}.ChosenObject_fl = []; %Which object was chosen
    res_mt{iS}.Outcome_fl = []; %whether reward was obtained
    res_mt{iS}.Accuracy_fl = []; %whether the correct choice was made
    res_mt{iS}.AbortCode_fl = [];

    res_mt{iS}.featuresShown_fl = [];
    res_mt{iS}.chosenObjectVector_fl = [];
    res_mt{iS}.chosenObjectPositionVector_fl = [];
    res_mt{iS}.targetObjectVector_fl =[];
    res_mt{iS}.targetObjectPositionVector_fl =[];
    res_mt{iS}.distractorVectors_fl =[];
    res_mt{iS}.distractorPositionVectors_fl =[];
    res_mt{iS}.TargetFeature_fl =[];

    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- specify which features to expect for WM:
    % --- --- --- --- --- --- --- --- --- --- --- ---

    res_mt{iS}.dimensionNums_wm = {};
    res_mt{iS}.dimensionNames_wm = {};
    res_mt{iS}.dimensionNums_wm{1}=1:9;
    res_mt{iS}.dimensionNames_wm{1}={'S01', 'S02', 'S03', 'S04', 'S05', 'S06', 'S07', 'S08', 'S09'};
    res_mt{iS}.dimensionNums_wm{2}=10:18;
    res_mt{iS}.dimensionNames_wm{2}={'P01', 'P02', 'P03', 'P04', 'P05', 'P06', 'P07', 'P08', 'P09'};
    res_mt{iS}.dimensionNums_wm{3}=19:26;
    res_mt{iS}.dimensionNames_wm{3}{1}={'C6070014_6070014', 'C6070059_6070059', 'C6070106_6070106', 'C6070148_6070148', 'C6070194_6070194', 'C6070239_6070239', 'C6070287_6070287', 'C6070335_6070335'};
    res_mt{iS}.dimensionNames_wm{3}{2}={'C7070014_5000000', 'C7070059_5000000', 'C7070106_5000000', 'C7070148_5000000', 'C7070194_5000000', 'C7070240_5000000', 'C7070286_5000000', 'C7070335_5000000'};
    res_mt{iS}.dimensionNums_wm{4}=27:37;
    res_mt{iS}.dimensionNames_wm{4}={'A00_E01', 'A00_E02', 'A00_E03', 'A01_E00', 'A01_E01', 'A01_E02', 'A01_E03', 'A02_E00', 'A02_E01', 'A02_E02', 'A02_E03'};
    res_mt{iS}.ObjectFeatureLabels_wm = [res_mt{iS}.dimensionNames_wm{1} res_mt{iS}.dimensionNames_wm{2} res_mt{iS}.dimensionNames_wm{3}{1} res_mt{iS}.dimensionNames_wm{4}];
    res_mt{iS}.DimensionVector_wm = [zeros(1,length(res_mt{iS}.dimensionNums_wm{1}))+1, zeros(1,length(res_mt{iS}.dimensionNums_wm{2}))+2, zeros(1,length(res_mt{iS}.dimensionNums_wm{3}))+3, zeros(1,length(res_mt{iS}.dimensionNums_wm{4}))+4];

    res_mt{iS}.TrialInBlock_wm = [];
    res_mt{iS}.ContextID_wm = [];
    res_mt{iS}.ITI_wm = [];
    res_mt{iS}.trialID_wm = {};
    res_mt{iS}.delayDuration_wm = [];
    res_mt{iS}.displaySampleDuration_wm = [];

    res_mt{iS}.BlockNum_wm = [];
    res_mt{iS}.TrialInExperiment_wm = [];
    res_mt{iS}.TrialInBlock_wm = [];
    res_mt{iS}.Outcome_wm  = [];
    res_mt{iS}.AllTokensCompleted_wm  = [];
    res_mt{iS}.TokenBarValue_wm  = [];
    res_mt{iS}.Accuracy_wm = [];
    res_mt{iS}.ReactionTime_wm = [];
    res_mt{iS}.AbortCode_wm = [];

    res_mt{iS}.chosenObjectVector_wm = [];
    res_mt{iS}.targetObjectVector_wm = [];
    res_mt{iS}.distractorVectors_wm = [];

    res_mt{iS}.chosenObjectPositionVector_wm = [];
    res_mt{iS}.targetObjectPositionVector_wm = [];
    res_mt{iS}.distractorPositionVectors_wm = [];

    res_mt{iS}.nDistractors_wm = [];
    res_mt{iS}.TDsharedFeatures_wm = [];

    res_mt{iS}.postSampleDist_wm = [];

    res_mt{iS}.cnd_DelaySec_wm = [];
    res_mt{iS}.cnd_DistractorSetSize_wm = [];


    for iD=1:length(datasets)

        in = load([datasetsDIR{iD} filesep datasets{iD}]); disp('.');

        % disp('hhh'), return
        
        if isempty(in.dat.taskLabel), disp(sprintf('empty tasklabel for iD=%d, %s',iD,datasets{iD})), continue, end

        % --- --- --- --- --- --- --- --- --- --- ---
        % --- get all instances of the current task (AS)
        % --- --- --- --- --- --- --- --- --- --- ---
        % idx_all = find(contains(in.dat.taskLabel,'FlexLearning'));
        % idx_all = find(contains(in.dat.taskLabel,'WorkingMemory'));
        % idx_all = find(contains(in.dat.taskLabel,'CR1'));
        idx_all = find(contains(in.dat.taskLabel,'AS'));
        if isempty(idx_all), res_mt{iS}(iD).log=[]; res_mt{iS}(iD).log{end+1} = 'task isempty...'; disp('task not found'); continue, end
        for iIDX = 1:length(idx_all)
            idx = idx_all(iIDX);


            disp(sprintf('processing AS iD=%d, %s',iD,datasets{iD})),
            if isempty(in.dat.trialData) & isempty(in.dat.blockData) ...
                    | (length(in.dat.trialData) < idx)  | (length(in.dat.blockData) < idx)
                disp('EMPTY data'),
                continue,
            end


            trialData_as = [];
            blockData_as = [];
            blockDef_as = [];
            stimDef_as = [];
            trialDef_as = [];
            if ~isempty(in.dat.trialData{idx})
                trialData_as = in.dat.trialData{idx};
            end

            if ~isempty(in.dat.blockData{idx})
                blockData_as = in.dat.blockData{idx};
            end

            if ~isempty(in.dat.cfg_BlockDef{idx})
                blockDef_as = table2struct(in.dat.cfg_BlockDef{idx});
            end
            if ~isempty(in.dat.cfg_StimDef{idx})
                stimDef_as  = table2struct(in.dat.cfg_StimDef{idx});
            end
            if ~isempty(in.dat.cfg_TrialDef{idx})
                trialDef_as = table2struct(in.dat.cfg_TrialDef{idx});
            end


            if length(trialData_as) < 2, sprintf('\nno trials in dataset %d (%s)', iD, datasets{iD}); continue, end

            res_mt{iS}(iD).datafolder = [datasetsDIR{iD}];
            res_mt{iS}(iD).dataset = [datasets{iD}];
            res_mt{iS}(iD).log = [];


            % res_mt{iS}(iD).nTrials_as  = length(trialData_as);

			all_trial_ids_cell = {trialData_as.TrialID};
			nonEmptyCount = sum(~cellfun(@isempty, all_trial_ids_cell));
			res_mt{iS}(iD).nTrials_as  = nonEmptyCount;

            for iT=1:res_mt{iS}(iD).nTrials_as
				% if isempty(trialData_as(iT).TrialID)
				% 	disp('Skip Empty Trial');
				% 	continue;
				% end
                res_mt{iS}(iD).SubjectID{iT}   = trialData_as(iT).SubjectID;
                res_mt{iS}(iD).ITI_as(iT)         = trialData_as(iT).ITI_Duration;

                res_mt{iS}(iD).trialID_as{iT}         = trialData_as(iT).TrialID;
                
                if contains(trialData_as(iT).TrialID, 'PS')
                    res_mt{iS}(iD).Pro1Anti2(iT) = 1;
                elseif contains(trialData_as(iT).TrialID, 'AS')
                    res_mt{iS}(iD).Pro1Anti2(iT) = 2;
                else
                    error('Unexpected trialID format');
                end

                res_mt{iS}(iD).BlockNum_as(iT)    = trialData_as(iT).BlockCount;
                if isnumeric(trialData_as(iT).TrialCount_InTask)
                    res_mt{iS}(iD).TrialInExperiment_as(iT) = trialData_as(iT).TrialCount_InTask;
                    res_mt{iS}(iD).TrialInBlock_as(iT)    = trialData_as(iT).TrialCount_InBlock;
                else
                    error('TrialCount_InTask not numeric - why?');
                end


                %res{iS}(iD).ContextID{iT}  = trialData(iT).ContextName; %Context
                res_mt{iS}(iD).Outcome_as(iT) = trialData_as(iT).TokenChange;%tTokenRewardSize(1:nTrials);
                %res{iS}(iD).AllTokensCompleted = strcmp(trialData(iT).GotTrialCorrect,'True');%TokenBarCompletedThisTrial
                res_mt{iS}(iD).TokenBarValue_as = trialData_as(iT).TokenBarValue;

                %res{iS}(iD).correctObjectPositionVector{iT} = [trialData(iT).SelectedLocation];
                res_mt{iS}(iD).Accuracy_as(iT) = strcmp(trialData_as(iT).GotTrialCorrect,'True');%trialData(iT).CorrectSelection;
                res_mt{iS}(iD).ReactionTime_as(iT) = trialData_as(iT).ReactionTime;
                res_mt{iS}(iD).AbortCode_as(iT) = trialData_as(iT).AbortCode;

                % what is the target stimulus ?
                res_mt{iS}(iD).TargetStimIndex_as(iT) = trialData_as(iT).TargetStimIndex;
                str = trialData_as(iT).DistractorStimIndices; str = strtrim(regexprep(str, '^\(|\)$', ''));tokens = strsplit(str, ','); iNums = [];for jj = 1:3, iNums(jj) = str2double(tokens{jj}); end
                res_mt{iS}(iD).DistractorStimIndices_as{iT} = iNums;

                % track cue and stim positions and durations:
                str = trialData_as(iT).SpatialCuePos; str = strtrim(regexprep(str, '^\(|\)$', ''));tokens = strsplit(str, ','); iLoc = [];for jj = 1:3, iLoc(jj) = str2double(tokens{jj}); end
                res_mt{iS}(iD).SpatialCuePos{iT} = iLoc;
                str = trialData_as(iT).TargetStimDisplayPos; str = strtrim(regexprep(str, '^\(|\)$', ''));tokens = strsplit(str, ','); iLoc = [];for jj = 1:3, iLoc(jj) = str2double(tokens{jj}); end
                res_mt{iS}(iD).TargetStimDisplayPos{iT} = iLoc;
                str = trialData_as(iT).TargetStimChoosePos; str = strtrim(regexprep(str, '^\(|\)$', ''));tokens = strsplit(str, ','); iLoc = [];for jj = 1:3, iLoc(jj) = str2double(tokens{jj}); end
                res_mt{iS}(iD).TargetStimChoosePos{iT} = iLoc;
                str = trialData_as(iT).DistractorStimsChoosePos; str = strtrim(regexprep(str, '^\(|\)$', ''));tokens = strsplit(str, ','); iLoc = [];for jj = 1:3, iLoc(jj) = str2double(tokens{jj}); end
                res_mt{iS}(iD).DistractorStimsChoosePos{iT} = iLoc;

                res_mt{iS}(iD).AlertCueDelay_Duration(iT) = trialData_as(iT).AlertCueDelay_Duration; %: 0.4150
                res_mt{iS}(iD).SpatialCueDelay_Duration(iT) = trialData_as(iT).SpatialCueDelay_Duration; %: 0.4150
                res_mt{iS}(iD).DisplayTarget_Duration(iT) = trialData_as(iT).DisplayTarget_Duration; %: 0.6200
                res_mt{iS}(iD).Mask_Duration(iT) = trialData_as(iT).Mask_Duration; %: 0.0150
                res_mt{iS}(iD).PostMaskDelay_Duration(iT) = trialData_as(iT).PostMaskDelay_Duration; %: 0.5150

                
            end

        end


        % --- --- --- --- --- --- --- --- --- --- ---
        % --- get all instances of the current task (CR)
        % --- --- --- --- --- --- --- --- --- --- ---
        idx_all = find(contains(in.dat.taskLabel,'CR1'));
        if isempty(idx_all), res_mt{iS}(iD).log=[]; res_mt{iS}(iD).log{end+1} = 'task isempty...'; disp('task not found'); continue, end
        for iIDX = 1:length(idx_all)
            idx = idx_all(iIDX);


            disp(sprintf('processing CR iD=%d, %s',iD,datasets{iD})),
            if isempty(in.dat.trialData) & isempty(in.dat.blockData) ...
                    | (length(in.dat.trialData) < idx)  | (length(in.dat.blockData) < idx)
                disp('EMPTY data'),
                continue,
            end


            trialData_cr = [];
            blockData_cr = [];
            blockDef_cr = [];
            stimDef_cr = [];
            trialDef_cr = [];
            if ~isempty(in.dat.trialData{idx})
                trialData_cr = in.dat.trialData{idx};
            end

            if ~isempty(in.dat.blockData{idx})
                blockData_cr = in.dat.blockData{idx};
            end

            if ~isempty(in.dat.cfg_BlockDef{idx})
                blockDef_cr = table2struct(in.dat.cfg_BlockDef{idx});
            end
            if ~isempty(in.dat.cfg_StimDef{idx})
                stimDef_cr  = table2struct(in.dat.cfg_StimDef{idx});
            end
            if idx <= length(in.dat.cfg_TrialDef) && ~isempty(in.dat.cfg_TrialDef{idx})
                trialDef_cr = table2struct(in.dat.cfg_TrialDef{idx});
            end


            if length(trialData_cr) < 2, sprintf('\nno trials in dataset %d (%s)', iD, datasets{iD}); continue, end

            res_mt{iS}(iD).datafolder = [datasetsDIR{iD}];
            res_mt{iS}(iD).dataset = [datasets{iD}];
            res_mt{iS}(iD).log = [];


            res_mt{iS}(iD).nTrials_cr  = length(trialData_cr);


            for iT=1:res_mt{iS}(iD).nTrials_cr
                res_mt{iS}(iD).SubjectID{iT}   = trialData_cr(iT).SubjectID;

                res_mt{iS}(iD).TrialCount_InTask{iT} = trialData_cr(iT).TrialCount_InTask;
                res_mt{iS}(iD).TrialCount_InBlock(iT) = trialData_cr(iT).TrialCount_InBlock;

                res_mt{iS}(iD).BlockCount(iT) = trialData_cr(iT).BlockCount;

                if isnumeric(trialData_cr(iT).TrialCount_InTask)
                    res_mt{iS}(iD).TrialInExperiment(iT) = trialData_cr(iT).TrialCount_InTask;
                    res_mt{iS}(iD).TrialInBlock(iT) = trialData_cr(iT).TrialCount_InBlock;
                else
                    error('TrialCount_InTask not numeric - why?');
                end

                if isfield(trialData_cr(iT), 'ChosenObjectCategory')
                    res_mt{iS}(iD).ChosenObjectCategory{iT} = trialData_cr(iT).ChosenObjectCategory;
                else
                    res_mt{iS}(iD).ChosenObjectCategory{iT} = NaN;
                end

                if strcmpi(trialData_cr(iT).ChoseCorrectly, 'True')
                    res_mt{iS}(iD).Accuracy(iT) = 1;
                elseif strcmpi(trialData_cr(iT).ChoseCorrectly, 'False')
                    res_mt{iS}(iD).Accuracy(iT) = 0;
                end

                if isfield(trialData_cr(iT), 'ReactionTime')
                    res_mt{iS}(iD).ReactionTime(iT) = trialData_cr(iT).ReactionTime;
                else
                    res_mt{iS}(iD).ReactionTime(iT) = NaN;
                end

                if isfield(trialData_cr(iT), 'ChosenObjectIndex') && strcmpi(trialData_cr(iT).ChosenObjectCategory, 'PC')
                        res_mt{iS}(iD).ObjectIndexAtError{end+1} = {int32(str2double(trialData_cr(iT).ChosenObjectIndex)), trialData_cr(iT).BlockCount, trialData_cr(iT).TrialCount_InBlock};
                end

                if isfield(trialData_cr(iT), 'ChosenObjectIndex')
                    currentBlock_cr = int32(str2double(trialData_cr(iT).BlockCount)) + 1;
                    
                    trialCell = { ...
                        int32(str2double(trialData_cr(iT).ChosenObjectIndex)), ...  
                        currentBlock_cr, ...                                       
                        int32(str2double(trialData_cr(iT).TrialCount_InBlock))};    

                    if numel(res_mt{iS}(iD).ChosenObjectIndex) < currentBlock_cr
                        res_mt{iS}(iD).ChosenObjectIndex{currentBlock_cr} = {};
                    elseif isempty(res_mt{iS}(iD).ChosenObjectIndex{currentBlock_cr})
                        res_mt{iS}(iD).ChosenObjectIndex{currentBlock_cr} = {};
                    end

                    
                    % Append the trialCell to the appropriate block row
                    res_mt{iS}(iD).ChosenObjectIndex{currentBlock_cr}{end+1} = trialCell;
                end



                res_mt{iS}(iD).CurrentTrialStims{iT} = trialData_cr(iT).CurrentTrialStims;
                res_mt{iS}(iD).ChoseCorrectly{iT} = trialData_cr(iT).ChoseCorrectly;

                str = trialData_cr(iT).CurrentTrialStims; str = str(2:end-1);  elements = strsplit(str, ', ');
                res_mt{iS}(iD).NumStimInTrial(iT) = length(elements);
            end
        end

        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        % --- get all instances of the current task (FL)
        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        
        res_mt{iS}(iD).dataset = [datasets{iD}];
        res_mt{iS}(iD).datafolder = [datasetsDIR{iD}];
        res_mt{iS}(iD).log = [];

        idx_all = find(contains(in.dat.taskLabel,'FlexLearning'));
        if isempty(idx_all), res_mt{iS}(iD).log=[]; res_mt{iS}(iD).log{end+1} = 'task isempty...'; disp('task not found'); continue, end
        
        for iIDX = 1:length(idx_all)
            indx = idx_all(iIDX);

            disp(sprintf('processing FL iD=%d, %s',iD,datasets{iD}));

            trialData_fl = [];
            blockData_fl = [];
            blockDef_fl = [];
            stimDef_fl = [];
            trialDef_fl = [];
			try
            if ~isempty(in.dat.trialData{indx})
                trialData_fl = in.dat.trialData{indx};
			end
			catch
				disp('EMPTY data'),
				continue
			end
            %disp(trialData)
    
            if ~isempty(in.dat.blockData{indx})
                blockData_fl = in.dat.blockData{indx};
            end
    
            if ~isempty(in.dat.cfg_BlockDef{indx})
                blockDef_fl = table2struct(in.dat.cfg_BlockDef{indx});
            end
    
            if ~isempty(in.dat.cfg_StimDef{indx})
                stimDef_fl  = table2struct(in.dat.cfg_StimDef{indx});
            end
            %disp(in.dat.cfg_StimDef{iIDX})
    
            if ~isempty(in.dat.cfg_TrialDef{indx})
                trialDef_fl = table2struct(in.dat.cfg_TrialDef{indx});
            end
    
            trialDef_block_trl = []; iTrialinBlock=0;
            for itdf=1:length(trialDef_fl)
                if itdf>1 & (trialDef_fl(itdf).BlockCount~=trialDef_fl(itdf-1).BlockCount)
                    iTrialinBlock=1;
                else
                    iTrialinBlock = iTrialinBlock + 1;
                end
                trialDef_block_trl(itdf,1:2) = [trialDef_fl(itdf).BlockCount iTrialinBlock];
            end
    
            % dat.blockData{idx};
            % dat.frameData{idx};
    
            res_mt{iS}(iD).nTrials_fl  = length(trialData_fl);
            % function FLData = get_trialData_FLUToken_02(iFileAndPath, iSessionName, trialdefname, trialData, blockData, blockjson, experimentID)
            for iT=1:res_mt{iS}(iD).nTrials_fl
                res_mt{iS}(iD).SubjectID_fl{iT}   = trialData_fl(iT).SubjectID;
                res_mt{iS}(iD).TrialID_fl{iT}  =  trialData_fl(iT).TrialID;
                res_mt{iS}(iD).ITI_fl(iT)         = trialData_fl(iT).ITI_Duration;
    
                res_mt{iS}(iD).BlockNum_fl(iT)    = trialData_fl(iT).BlockCount;
    
                if isnumeric(trialData_fl(iT).TrialCount_InTask)
                    res_mt{iS}(iD).TrialInExperiment_fl(iT) = trialData_fl(iT).TrialCount_InTask;
                    res_mt{iS}(iD).TrialInBlock_fl(iT)    = trialData_fl(iT).TrialCount_InBlock;
                end
    
                if ~isfield(trialData_fl,'Context') & isfield(trialData_fl, 'ContextName')
                    trialData_fl(iT).Context = trialData_fl(iT).ContextName;
                end
                %disp(trialData(iT))
                %res(iD).ContextID{iT}  = trialData(iT).ContextName; % Context
                res_mt{iS}(iD).Outcome_fl(iT) = trialData_fl(iT).TokenChange;%tTokenRewardSize(1:nTrials);
                % if ~isfield(trialData,'TokenBarCompletedThisTrial') & isfield(trialData, 'TokenBarFull')
                %     trialData(iT).TokenBarCompletedThisTrial = trialData(iT).ContextName;
                % end
                %res(iD).AllTokensCompleted = strcmp(trialData(iT).TokenBarCompletedThisTrial,'True');
                res_mt{iS}(iD).TokenBarValue_fl = trialData_fl(iT).TokenBarValue;
    
                % if ~isequal(trialData(iT).TaskName, 'FlexLearning')
                %     continue,
                % end
                if isempty(trialData_fl(iT).SelectedLocation)
                    continue, 
                end
    
    
    
                res_mt{iS}(iD).ChosenLocation_fl{iT} = trialData_fl(iT).SelectedLocation;
                res_mt{iS}(iD).Accuracy_fl(iT) = trialData_fl(iT).CorrectSelection;
                res_mt{iS}(iD).ReactionTime_fl(iT) = trialData_fl(iT).SearchDuration;
                res_mt{iS}(iD).AbortCode_fl(iT) = trialData_fl(iT).AbortCode;
    
    
    
                
    
                % ----
                % ---- for Quaddle 1.0 stimuli specified in the stimDef:
                % ---- specify for each stimulus in this trial the features it carried
                % ----
                % ---- requires: (1) stimulus indices in trialData : iStimIndices
                % ----           (2) the stimDef with index - name pairs : stimDef
                % ----           (3) dimension information about feature the filename
                % ----               refers to : dimensionNames, dimensionNums
                % ----
                iTrial = trialData_fl(iT).TrialCount_InTask;
                iTrialInBlock = trialData_fl(iT).TrialCount_InBlock;
                iBlock = trialData_fl(iT).BlockCount;
    
                % --- find matching triaDef row to extract stimulus index
                iTrialTrialDef = find(trialDef_block_trl(:,1)==iBlock & trialDef_block_trl(:,2)==iTrialInBlock);
    
                % --- --- --- --- --- --- ---
                % --- specifc the chosen stimulus and chosen location
                % --- (from trialData)
                % --- --- --- --- --- --- ---
                %iChosenStimIdx = trialData(iT).SelectedStimIndex;
                if isfield(trialData_fl(iT), 'SelectedStimIndex') && ~isempty(trialData_fl(iT).SelectedStimIndex)
                    iChosenStimIdx = trialData_fl(iT).SelectedStimIndex;
                else
                    iChosenStimIdx = NaN;
                    disp('SelectedStimIndex (trialData) is null')
                end
    
                objectVectorInformation = get_objectVector_02(iChosenStimIdx, stimDef_fl, res_mt{iS}(1).dimensionNames, res_mt{iS}(1).dimensionNums);
                res_mt{iS}(iD).chosenObjectVector_fl(iT,:) = objectVectorInformation{1};
                trialData_fl(iT).SelectedLocation([findstr(trialData_fl(iT).SelectedLocation,'(') findstr(trialData_fl(iT).SelectedLocation,')')])=[];
                if isnan(trialData_fl(iT).SelectedLocation)
                    disp('SelectedLocation is NaN... skipping');
                    continue
                    %res_mt{iS}(iD).chosenObjectPositionVector_fl(iT,:) = NaN;
                else
                    res_mt{iS}(iD).chosenObjectPositionVector_fl(iT,:) = str2num(trialData_fl(iT).SelectedLocation);
                end
    
                % --- --- --- --- --- --- ---
                % --- for other (none chosen stimuli) look at trialDef specifications
                % --- the first stimindex is the target (per definition)
                % --- --- --- --- --- --- ---
    
                if isfield(trialDef_fl(iTrialTrialDef), 'TrialStimIndices') && ~isempty(trialDef_fl(iTrialTrialDef).TrialStimIndices)
                    iStimIndices = str2num(trialDef_fl(iTrialTrialDef).TrialStimIndices);
                else
                    iStimIndices = NaN;
                    disp('TrialStimIndices (trialDef) is null')
                end
    
                if isfield(trialDef_fl(iTrialTrialDef), 'TrialStimLocations') && ~isempty(trialDef_fl(iTrialTrialDef).TrialStimLocations)
                    iLocationsXYZ = str2num(trialDef_fl(iTrialTrialDef).TrialStimLocations);
                else
                    iLocationsXYZ = NaN;
                    disp('TrialStimLocations (trialDef) is null')
                end
    
                % --- check chosen stimulus was in stimulus list of stimDef file
                if isempty(find(iChosenStimIdx==iStimIndices)), error('fatal error: no target indices (in trialData) found in trialDef TrialStimIndices'), end
    
                % --- the first stimindex is the target (per definition)
                iTargetStimIndex = iStimIndices(1);
                objectVectorInformation = get_objectVector_02(iTargetStimIndex, stimDef_fl, res_mt{iS}(1).dimensionNames, res_mt{iS}(1).dimensionNums);
                res_mt{iS}(iD).targetObjectVector_fl(iT,:) = objectVectorInformation{1};
                res_mt{iS}(iD).targetObjectPositionVector_fl(iT,:) = iLocationsXYZ(1:3);
                % --- the second to last stimindices are distractors (per definition)
                res_mt{iS}(iD).distractorVectors_fl{iT} = [];
                res_mt{iS}(iD).distractorPositionVectors_fl{iT} = [];
                if length(iStimIndices)>1 % only find object vectors of distractors if there are distractors
                    iStimIndices(1)=[];
                    objectVectorInformation = get_objectVector_02(iStimIndices, stimDef_fl, res_mt{iS}(1).dimensionNames, res_mt{iS}(1).dimensionNums);
                    res_mt{iS}(iD).distractorVectors_fl{iT} = objectVectorInformation;
                    iP=0;
                    for p=1:3:length(iStimIndices)*3
                        iP=iP+1;
                        res_mt{iS}(iD).distractorPositionVectors_fl{iT}(iP,:) = iLocationsXYZ(p+[0 1 2]);
                    end
                end
            end
        end
        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        % --- extract the actual target feature er block
        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        blockStarts = find([1 diff(res_mt{iS}(iD).BlockNum_fl)]);
        for k=1:length(blockStarts)
            if k == length(blockStarts)
                idx = blockStarts(k):length(res_mt{iS}(iD).BlockNum_fl);
            else
                idx = blockStarts(k): blockStarts(k+1)-1;
			end
			if isempty(res_mt{iS}(iD).targetObjectVector_fl)
				res_mt{iS}(iD).TargetFeature_fl(idx) = NaN;
			else
            	if length(res_mt{iS}(iD).targetObjectVector_fl(:,1)) >= idx
                	[a,tfeat]=max(sum(res_mt{iS}(iD).targetObjectVector_fl(idx,:),1));
                	res_mt{iS}(iD).TargetFeature_fl(idx) = tfeat;
            	else
                	%fprintf_('dataset%d idx: %d | length: %d\n', iD, idx, length(res(iD).targetObjectVector));
                	res_mt{iS}(iD).TargetFeature_fl(idx) = NaN;
				end
			end
        end


        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        % --- get all instances of the current task (WM)
        % --- --- --- --- --- --- --- --- --- --- --- --- ---

        idx_all = find(contains(in.dat.taskLabel,'WorkingMemory'));
        if isempty(idx_all), res_mt{iS}(iD).log=[]; res_mt{iS}(iD).log{end+1} = 'task isempty...'; disp('task not found'); continue, end
        for iIDX = 1:length(idx_all)
            idx = idx_all(iIDX);


            disp(sprintf('processing WM iD=%d, %s',iD,datasets{iD})),
            if isempty(in.dat.trialData) & isempty(in.dat.blockData) ...
                    | (length(in.dat.trialData) < idx)  | (length(in.dat.blockData) < idx)
                disp('EMPTY data'),
                continue,
            end


            trialData_wm = [];
            blockData_wm = [];
            blockDef_wm = [];
            stimDef_wm = [];
            trialDef_wm = [];
            if ~isempty(in.dat.trialData{idx})
                trialData_wm = in.dat.trialData{idx};
            end

            if ~isempty(in.dat.blockData{idx})
                blockData_cr = in.dat.blockData{idx};
            end

            if ~isempty(in.dat.cfg_BlockDef{idx})
                blockDef_wm = table2struct(in.dat.cfg_BlockDef{idx});
            end
            if ~isempty(in.dat.cfg_StimDef{idx})
                stimDef_wm  = table2struct(in.dat.cfg_StimDef{idx});
            end
            if idx <= length(in.dat.cfg_TrialDef) && ~isempty(in.dat.cfg_TrialDef{idx})
                trialDef_wm = table2struct(in.dat.cfg_TrialDef{idx});
            end


            if length(trialData_wm) < 2, sprintf('\nno trials in dataset %d (%s)', iD, datasets{iD}); continue, end

            res_mt{iS}(iD).datafolder = [datasetsDIR{iD}];
            res_mt{iS}(iD).dataset = [datasets{iD}];
            res_mt{iS}(iD).log = [];


            trialData_wm = [];
            blockData_wm = [];
            blockDef_wm = [];
            stimDef_wm = [];
            trialDef_wm = [];
            if ~isempty(in.dat.trialData{idx})
                trialData_wm = in.dat.trialData{idx};
            end
    
            if ~isempty(in.dat.blockData{idx})
                blockData_wm = in.dat.blockData{idx};
            end
    
            if ~isempty(in.dat.cfg_BlockDef{idx})
                blockDef_wm = table2struct(in.dat.cfg_BlockDef{idx});
            end
            if ~isempty(in.dat.cfg_StimDef{idx})
                stimDef_wm  = table2struct(in.dat.cfg_StimDef{idx});
            end
            if ~isempty(in.dat.cfg_TrialDef{idx})
                trialDef_wm = table2struct(in.dat.cfg_TrialDef{idx});
            end
            % dat.blockData{idx};
            % dat.frameData{idx};
    
            res_mt{iS}(iD).nTrials_wm  = length(trialData_wm);
    
            % function FLData = get_trialData_FLUToken_02(iFileAndPath, iSessionName, trialdefname, trialData, blockData, blockjson, experimentID)
            for iT=1:res_mt{iS}(iD).nTrials_wm
                res_mt{iS}(iD).SubjectID_wm{iT}   = trialData_wm(iT).SubjectID;
                res_mt{iS}(iD).monkey_wm{iT} = iSubject;
                %res(iD).condition{iT} = iDrugCondition;
                %res(iD).weekDay{iT} = iWeekDay;
                
                res_mt{iS}(iD).ITI_wm(iT)         = trialData_wm(iT).ITI_Duration;
    
                res_mt{iS}(iD).trialID_wm{iT}         = trialData_wm(iT).TrialID;
    
                res_mt{iS}(iD).delayDuration_wm(iT)         = trialData_wm(iT).Delay_Duration;
                res_mt{iS}(iD).displaySampleDuration_wm(iT)         = trialData_wm(iT).DisplaySample_Duration;
    
                % TrialID: 'WMn1.TDSIM1_delay1.0' but Delay_Duration: 0.5171 and the
                % framedta suggests: (3542-3513)*(1000/60)
                % what is DisplaySample_Duration
    
                res_mt{iS}(iD).BlockNum_wm(iT)    = trialData_wm(iT).BlockCount;
                if isnumeric(trialData_wm(iT).TrialCount_InTask)
                    res_mt{iS}(iD).TrialInExperiment_wm(iT) = trialData_wm(iT).TrialCount_InTask;
                    res_mt{iS}(iD).TrialInBlock_wm(iT)    = trialData_wm(iT).TrialCount_InBlock;
                else
                    error('TrialCount_InTask not numeric - why?');
                end
    
                res_mt{iS}(iD).ContextID_wm{iT}  = trialData_wm(iT).ContextName; %Context
                res_mt{iS}(iD).Outcome_wm(iT) = trialData_wm(iT).TokenChange;%tTokenRewardSize(1:nTrials);
                %res(iD).AllTokensCompleted = strcmp(trialData(iT).TokenBarFull,'True');%TokenBarCompletedThisTrial
                res_mt{iS}(iD).TokenBarValue_wm(iT) = trialData_wm(iT).TokenBarValue;
                res_mt{iS}(iD).TokenChange_wm(iT) = trialData_wm(iT).TokenChange;
    
                res_mt{iS}(iD).correctObjectPositionVector_wm{iT} = [trialData_wm(iT).SelectedLocation];
                res_mt{iS}(iD).Accuracy_wm(iT) = trialData_wm(iT).CorrectSelection;
                res_mt{iS}(iD).ReactionTime_wm(iT) = trialData_wm(iT).SearchDuration;
                res_mt{iS}(iD).AbortCode_wm(iT) = trialData_wm(iT).AbortCode;



                % --- if the trial was aborted then continue
                if isnan(trialData_wm(iT).SelectedStimCode),
                    res_mt{iS}(iD).chosenObjectVector_wm(iT,:)            = nan(1,max(res_mt{iS}(1).dimensionNums_wm{end}));
                    res_mt{iS}(iD).chosenObjectPositionVector_wm(iT,:)    = nan(1,3);
                    res_mt{iS}(iD).targetObjectVector_wm(iT,:)            = nan(1,max(res_mt{iS}(1).dimensionNums_wm{end}));
                    res_mt{iS}(iD).targetObjectPositionVector_wm(iT,:)    = nan(1,3);
                    res_mt{iS}(iD).distractorVectors_wm{iT}               = [];
                    res_mt{iS}(iD).distractorPositionVectors_wm{iT}       = [];
                    continue,
                end
    
    
                % --- --- --- --- --- --- --- --- --- --- --- ---
                % --- for Quaddle 1.0 stimuli specified in the stimDef:
                % --- specify for each stimulus in this trial the features it carried
                % ---
                % --- requires: (1) stimulus indices in trialData : iStimIndices
                % ---           (2) the stimDef with index - name pairs : stimDef
                % ---           (3) dimension information about feature the filename
                % ---               refers to : dimensionNames, dimensionNums
                % --- --- --- --- --- --- --- --- --- --- --- ---
                iTrial_wm = trialData_wm(iT).TrialCount_InTask;
    
                % --- --- --- --- --- --- ---
                % --- specifc the chosen stimulus and chosen location
                % --- --- --- --- --- --- ---
                %iChosenStimIdx = trialData(iT).SelecteStimIndex; %SelectedStimIndex
                %NOTE: trialData(iT).SelectedStimCode is always 0 in working memory task....
                %        iChosenStimIdx = trialData(iT).SelectedStimCode; %SelectedStimIndex
                %        objectVectorInformation = get_objectVector_01(iChosenStimIdx, stimDef, res.dimensionNames, res.dimensionNums);
                %        res(iD).chosenObjectVector(iT,:) = objectVectorInformation{1};
                trialData_wm(iT).SelectedLocation([findstr(trialData_wm(iT).SelectedLocation,'(') findstr(trialData_wm(iT).SelectedLocation,')')])=[];
                %        res(iD).chosenObjectPositionVector(iT,:) = str2num(trialData(iT).SelectedLocation);
    
                % --- --- --- --- --- --- ---
                % --- the first stimindex is the target (per definition)
                % --- --- --- --- --- --- ---
    
                %iStimIndices = str2num(trialDef(iTrial).TrialStimIndices);
                %iLocationsXYZ = str2num(trialDef(iTrial).TrialStimLocations);
                iStimIndices_wm = str2num(trialDef_wm(iTrial_wm).SearchStimIndices);
                iLocationsXYZ_wm = str2num(trialDef_wm(iTrial_wm).SearchStimLocations);

                if strcmp(trialDef_wm(iTrial_wm).PostSampleDistractorStimIndices, '[]') % there WAS NOT a post sample distractor
                    res_mt{iS}(iD).postSampleDist_wm(iT) = 0;
                else % there WAS a post sample distractor
                    res_mt{iS}(iD).postSampleDist_wm(iT) = 1;
                end
                fprintf('postSampleDist_wm (iT=%d) = %d\n', iT, res_mt{iS}(iD).postSampleDist_wm(iT));
    
                % --- check chosen stimnulus was in stimulus list of stimDef file
                %if isempty(find(iChosenStimIdx==iStimIndices)), error('fatal error: not target indices (in trialData) found in trialDef stimindices'), end
    
                % --- the first stimindex is the target (per definition)
                iTargetStimIndex_wm = iStimIndices_wm(1);
                objectVectorInformation_wm = get_objectVector_01(iTargetStimIndex_wm, stimDef_wm, res_mt{iS}(1).dimensionNames_wm, res_mt{iS}(1).dimensionNums_wm);
                %disp(stimDef_wm)
                res_mt{iS}(iD).targetObjectVector_wm(iT,:) = objectVectorInformation_wm{1};
                res_mt{iS}(iD).targetObjectPositionVector_wm(iT,:) = iLocationsXYZ_wm(1:3);
    
                % --- the second to last stimindices are distractors (per definition)
                res_mt{iS}(iD).distractorVectors_wm{iT} = [];
                res_mt{iS}(iD).distractorPositionVectors_wm{iT} = [];

                %fprintf('length of iStimIndices_wm: %d\n', length(iStimIndices_wm))
                %disp(iStimIndices_wm);

                if length(iStimIndices_wm)>1 % only find object vectors of distractors if there are distractors
                    iStimIndices_wm(1)=[];
                    objectVectorInformation_wm = get_objectVector_01(iStimIndices_wm, stimDef_wm, res_mt{iS}(1).dimensionNames_wm, res_mt{iS}(1).dimensionNums_wm);
                    %disp(objectVectorInformation_wm)
                    res_mt{iS}(iD).distractorVectors_wm{iT} = objectVectorInformation_wm;
                    iP=0;
                    for p=1:3:length(iStimIndices_wm)*3
                        iP=iP+1;
                        res_mt{iS}(iD).distractorPositionVectors_wm{iT}(iP,:) = iLocationsXYZ_wm(p+[0 1 2]);
                    end
                    % --- if chosen object is this distractor its at the same location ...
                    tmp = str2num(trialData_wm(iT).SelectedLocation);
                    if sum(tmp == res_mt{iS}(iD).distractorPositionVectors_wm{iT})==3
                        res_mt{iS}(iD).chosenObjectVector_wm(iT,:) = res_mt{iS}(iD).distractorVectors_wm{iT}{:};
                    end
    
                end
    
                % --- if chosen object is target its at the same location ...
                tmp = str2num(trialData_wm(iT).SelectedLocation);
                % disp(size(tmp));
                % disp(size(res_mt{iS}(iD).targetObjectPositionVector_wm));
                if sum(tmp == res_mt{iS}(iD).targetObjectPositionVector_wm)==3
                    res_mt{iS}(iD).chosenObjectVector_wm(iT,:) = res_mt{iS}(iD).targetObjectVector_wm(iT,:);
                end



                % --- collect information about number of distractors and how many feature
                % --- were are shared between distractor and target ?
    
                res_mt{iS}(iD).nDistractors_wm(iT) = length(res_mt{iS}(iD).distractorVectors_wm{iT});
                res_mt{iS}(iD).TDsharedFeatures_wm(iT, 1:4) = nan(1, 4);

                if ~isempty(res_mt{iS}(iD).distractorVectors_wm{iT})
                    tmp = [];
                    %fprintf('iDV goes until %d\n', length(res_mt{iS}(iD).distractorVectors_wm{iT}))
                    %disp(res_mt{iS}(iD).distractorVectors_wm{iT});
                    for iDV=1:length(res_mt{iS}(iD).distractorVectors_wm{iT})
                        tmp(iDV) = sum(sum(cat(1,res_mt{iS}(iD).targetObjectVector_wm(iT,:), res_mt{iS}(iD).distractorVectors_wm{iT}{iDV}),1)==2);

                        % disp('targetObjectVector_wm')
                        % disp(size(res_mt{iS}(iD).targetObjectVector_wm(iT,:)));
                        % disp('distractorVectors_wm')
                        % disp(size(res_mt{iS}(iD).distractorVectors_wm{iT}{iDV}));

                    end
                    res_mt{iS}(iD).TDsharedFeatures_wm(iT,1:length(tmp)) = tmp;
                    %disp(res_mt{iS}(iD).TDsharedFeatures_wm(iT,1:length(tmp)));
                end


                % if ~isempty(res_mt{iS}(iD).distractorVectors_wm{iT})
                %     tmp = [];
                %     for iDV = 1:length(res_mt{iS}(iD).distractorVectors_wm{iT})
                %         % Ensure targetObjectVector and distractorVec are row vectors
                %         targetVec = res_mt{iS}(iD).targetObjectVector_wm(iT,:);
                %         distractorVec = res_mt{iS}(iD).distractorVectors_wm{iT}{iDV};
                % 
                %         % disp(size(targetVec))
                %         % disp(size(distractorVec))
                % 
                %         % Perform element-wise comparison and sum
                %         tmp(iDV) = sum(targetVec == 2 & distractorVec == 2);
                %     end
                %     disp(tmp)
                %     res_mt{iS}(iD).TDsharedFeatures_wm(iT, 1:length(tmp)) = tmp;
                % end
                        sprintf('done with dataset %d\n', iD);
            end

            
        end




        sprintf('done with dataset %d\n', iD);
    end
    
end
    % --- --- --- --- --- --- --- --- --- --- --- --- ---
    % --- save analysis results in RES file
    % --- --- --- --- --- --- --- --- --- --- --- --- ---
    if ~exist(cfg.RESULTFOLDER), mkdir(cfg.RESULTFOLDER); end
    save([cfg.RESULTFOLDER filesep cfg.RESULTFILE],'res_mt','-V7.3')
    fprintf('saved analysis of n=%d subjects in %s \n',numel(cfg.analysisID), cfg.RESULTFILE),
end


% --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- do some basic analysis
% --- --- --- --- --- --- --- --- --- --- --- --- ---
if cfg.do_AnalysisBasic == 1

metrics_mt = cell(1, numel(cfg.analysisID));

for iS=1:numel(cfg.analysisID)
    % --- --- --- --- --- --- --- --- --- --- ---
    % --- load results if they are not yet loaded
    % --- --- --- --- --- --- --- --- --- --- ---
    if ~exist('metrics_mt')
        load([cfg.RESULTFOLDER  filesep cfg.iResultFile]);
	end

	

    % --- --- --- --- --- --- --- --- --- --- ---
    % --- AS conditions
    % --- --- --- --- --- --- --- --- --- --- ---
    iConditions_targetDurations = [0.35];
    %iConditions_delayDurations = [0 0.1 0.2];
    iConditions_delayDurations = [0];
    iConditions_Pro1Anti2 = [1 2];
    iConditions_ChoosePos = [{[-1.2000, 0.8000, 0]} {[1.2000, 0.8000, 0]} {[1.2000, -1.2000, 0]} {[-1.2000, -1.2000, 0]}];
    iConditions_DisplayPos = [{[-3, 0, 0]} {[3, 0, 0]}];
    iConditions_stimIndices = [0 1 2 3 4 5 6 7];
    iConditions_Congruency = {'left-left', 'left-right', 'right-right', 'right-left'};
    iConditions_Durations = NaN(length(iConditions_targetDurations) * length(iConditions_delayDurations), 2);
    icnt=0;
    for j=1:length(iConditions_targetDurations)
        for k=1:length(iConditions_delayDurations)
            icnt=icnt+1;
            iConditions_Durations(icnt,1:2) = [iConditions_targetDurations(j) iConditions_delayDurations(k)];
        end
    end

    % --- --- --- --- --- --- --- --- --- --- ---
    % --- CR Conditions
    % --- --- --- --- --- --- --- --- --- --- ---
    iConditions_ChosenObjectCategory = {'PC', 'New', 'PNC'};
    iConditions_StimInTrial = 2:20;

    % --- --- --- --- --- --- --- --- --- --- ---
    % --- WM Conditions
    % --- --- --- --- --- --- --- --- --- --- ---
    tmpDelays = [1.3, 5.1, 2.3, 0.3, 3.8];  % Row vector
    % tmpDelays = [0.25:0.25:6.0];
    %size(tmpDelays)
    iConditions_nDistractors = [2 3]; %used to be [1 2 3]
    iConditions_PSD = [0 1];
    iConditions_delays = tmpDelays;

    iConditions_wm = [];icnt=0;
    for j=1:length(iConditions_nDistractors)
        for k=1:length(iConditions_delays)
            icnt=icnt+1;
            iConditions_wm(icnt,1:2) = [iConditions_nDistractors(j) iConditions_delays(k)];
        end
    end

    iConditions2_wm = [];icnt=0;
    for j=1:length(iConditions_PSD)
        for k=1:length(iConditions_delays)
            icnt=icnt+1;
            iConditions2_wm(icnt,1:2) = [iConditions_PSD(j) iConditions_delays(k)];
        end
    end
    
    for iD=1:length(res_mt{iS})
		
		if isempty(res_mt{iS}(iD).dataset)
            continue
		end
        % --- --- --- --- --- --- --- --- --- --- ---
        % --- Filling metrics_mt with AS statistics
        % --- --- --- --- --- --- --- --- --- --- ---
		
        % --- averages in metrics_mt - initialization

        % pro vs anti
        metrics_mt{iS}(iD).AccuracyMeanSE_Pro(1:4) = NaN;
        metrics_mt{iS}(iD).AccuracyMeanSE_Anti(1:4) = NaN;
        metrics_mt{iS}(iD).RTMeanSE_Pro(1:4) = NaN;
        metrics_mt{iS}(iD).RTMeanSE_Anti(1:4) = NaN;

        % difference scores
        metrics_mt{iS}(iD).AccuracyMeanSE_ProMinusAnti(1:4) = NaN;
        metrics_mt{iS}(iD).RTMeanSE_ProMinusAnti(1:4) = NaN;

        % congruency: row corresponds to display-chose combinations
        metrics_mt{iS}(iD).Accuracy_Pro_Cong = NaN(length(iConditions_Congruency), 4);
        metrics_mt{iS}(iD).RT_Pro_Cong = NaN(length(iConditions_Congruency), 4);
        metrics_mt{iS}(iD).Accuracy_Anti_Cong = NaN(length(iConditions_Congruency), 4);
        metrics_mt{iS}(iD).RT_Anti_Cong = NaN(length(iConditions_Congruency), 4);
        metrics_mt{iS}(iD).Accuracy_Cong_Combined = NaN(length(iConditions_Congruency),4);
        metrics_mt{iS}(iD).RT_Cong_Combined = NaN(length(iConditions_Congruency),4);


        % --- tmp variables - initialization

        % pro vs anti
        tmpProAcc = NaN(1, res_mt{iS}(iD).nTrials_as);
        tmpAntiAcc = NaN(1, res_mt{iS}(iD).nTrials_as);
        tmpProRT = NaN(1, res_mt{iS}(iD).nTrials_as);
        tmpAntiRT = NaN(1, res_mt{iS}(iD).nTrials_as);

        % choose target location: row corresponds to target stim choose quadrant
        tmpProLocAcc = NaN(4, res_mt{iS}(iD).nTrials_as);
        tmpProLocRT = NaN(4, res_mt{iS}(iD).nTrials_as);
        tmpAntiLocAcc = NaN(4, res_mt{iS}(iD).nTrials_as);
        tmpAntiLocRT = NaN(4, res_mt{iS}(iD).nTrials_as);

        % display target location: row 1 ==> left display; row 2 ==> right display
        tmpProDispLocAcc = NaN(2, res_mt{iS}(iD).nTrials_as);
        tmpProDispLocRT = NaN(2, res_mt{iS}(iD).nTrials_as);
        tmpAntiDispLocAcc = NaN(2, res_mt{iS}(iD).nTrials_as);
        tmpAntiDispLocRT = NaN(2, res_mt{iS}(iD).nTrials_as);

        % durations: each row (20) ==> unique target x delay combo
        tmpProDurationAcc = NaN(length(iConditions_targetDurations) * length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpProDurationRT = NaN(length(iConditions_targetDurations) * length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiDurationAcc = NaN(length(iConditions_targetDurations) * length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiDurationRT = NaN(length(iConditions_targetDurations) * length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);

        % display target duration: row corresponds to display target duration
        tmpProDTDAcc = NaN(length(iConditions_targetDurations), res_mt{iS}(iD).nTrials_as);
        tmpProDTDRT = NaN(length(iConditions_targetDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiDTDAcc = NaN(length(iConditions_targetDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiDTDRT = NaN(length(iConditions_targetDurations), res_mt{iS}(iD).nTrials_as);
        
        % spatial cue delay duration: row corresponds to display target duration
        tmpProSCDDAcc = NaN(length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpProSCDDRT = NaN(length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiSCDDAcc = NaN(length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);
        tmpAntiSCDDRT = NaN(length(iConditions_delayDurations), res_mt{iS}(iD).nTrials_as);

        % congruency: row corresponds to display-chose combinations
        tmpProCongAcc = NaN(length(iConditions_Congruency), res_mt{iS}(iD).nTrials_as);
        tmpProCongRT = NaN(length(iConditions_Congruency), res_mt{iS}(iD).nTrials_as);
        tmpAntiCongAcc = NaN(length(iConditions_Congruency), res_mt{iS}(iD).nTrials_as);
        tmpAntiCongRT = NaN(length(iConditions_Congruency), res_mt{iS}(iD).nTrials_as);


        tmpStimIndexAcc = NaN(length(iConditions_stimIndices), res_mt{iS}(iD).nTrials_as);
        tmpStimIndexRT = NaN(length(iConditions_stimIndices), res_mt{iS}(iD).nTrials_as);


        % --- populating tmp structures
        
        for iT = 1:res_mt{iS}(iD).nTrials_as
			if iT > length(res_mt{iS}(iD).SpatialCueDelay_Duration)
				continue;
			end
            if abs(res_mt{iS}(iD).SpatialCueDelay_Duration(iT) - iConditions_delayDurations(1)) <= 0.025
                if res_mt{iS}(iD).Pro1Anti2(iT) == iConditions_Pro1Anti2(1)
                    % pre-calculating statistics for Pro trials only
                    tmpProAcc(iT) = res_mt{iS}(iD).Accuracy_as(iT);
                    tmpProRT(iT) = res_mt{iS}(iD).ReactionTime_as(iT);
        
    
                    % pre-calculating statistics for congruency (accounting for rotation, splitting screen to left vs right)
                    % if target display left and choose pos  left (left-left)
                    if isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(1)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) < -0.100) % if only consider outer-most, use 0.8 as threshold
                        tmpProCongAcc(1, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpProCongRT(1, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display left and choose pos is right (left-right)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(1)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) > 0.100)
                        tmpProCongAcc(2, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpProCongRT(2, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display right and choose pos right (right-right)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(2)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) > 0.100)
                        tmpProCongAcc(3, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpProCongRT(3, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display right and choose pos left (right-left)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(2)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) < -0.100)
                        tmpProCongAcc(4, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpProCongRT(4, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    end
   
                elseif res_mt{iS}(iD).Pro1Anti2(iT) == iConditions_Pro1Anti2(2)
				% else
                    % pre-calculating statistics for Anti trials only
                    tmpAntiAcc(iT) = res_mt{iS}(iD).Accuracy_as(iT);
                    tmpAntiRT(iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                        
                    % pre-calculating statistics for congruency (accounting for rotation, splitting screen to left vs right)
                    % if target display left and choose pos  left (left-left)
                    if isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(1)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) < -0.100) % if only consider outer-most, use 0.8 as threshold
                        tmpAntiCongAcc(1, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpAntiCongRT(1, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display left and choose pos is right (left-right)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(1)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) > 0.100)
                        tmpAntiCongAcc(2, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpAntiCongRT(2, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display right and choose pos right (right-right)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(2)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) > 0.100)
                        tmpAntiCongAcc(3, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpAntiCongRT(3, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    % if target display right and choose pos left (right-left)
                    elseif isequal(res_mt{iS}(iD).TargetStimDisplayPos(iT), iConditions_DisplayPos(2)) && (res_mt{iS}(iD).TargetStimChoosePos{iT}(1) < -0.100)
                        tmpAntiCongAcc(4, iT) = res_mt{iS}(iD).Accuracy_as(iT);
                        tmpAntiCongRT(4, iT) = res_mt{iS}(iD).ReactionTime_as(iT);
                    end

                end
            end
        end

        % --- combining pro and anti

        tmpCongAcc_Combined = [tmpProCongAcc, tmpAntiCongAcc];
        tmpCongRT_Combined = [tmpProCongRT, tmpAntiCongRT];
        
        % --- clearing out NaNs
        tmpProAcc = tmpProAcc(~isnan(tmpProAcc));
        tmpProRT = tmpProRT(~isnan(tmpProRT));
        tmpAntiAcc = tmpAntiAcc(~isnan(tmpAntiAcc));
        tmpAntiRT = tmpAntiRT(~isnan(tmpAntiRT));

        % --- populating metrics_mt

        % --- calculating mean, std, SE, count for saccade type
        metrics_mt{iS}(iD).AccuracyMeanSE_Pro = [mean(tmpProAcc), median(tmpProAcc), std(tmpProAcc)/sqrt(length(tmpProAcc)), length(tmpProAcc)];
        metrics_mt{iS}(iD).AccuracyMeanSE_Anti = [mean(tmpAntiAcc), median(tmpAntiAcc), std(tmpAntiAcc)/sqrt(length(tmpAntiAcc)), length(tmpAntiAcc)];
        metrics_mt{iS}(iD).RTMeanSE_Pro = [mean(tmpProRT), median(tmpProRT), std(tmpProRT)/sqrt(length(tmpProRT)), length(tmpProRT)];
        metrics_mt{iS}(iD).RTMeanSE_Anti = [mean(tmpAntiRT), median(tmpAntiRT), std(tmpAntiRT)/sqrt(length(tmpAntiRT)), length(tmpAntiRT)];
    
        % --- getting difference scores
        metrics_mt{iS}(iD).RTMeanSE_ProMinusAnti = metrics_mt{iS}(iD).RTMeanSE_Pro - metrics_mt{iS}(iD).RTMeanSE_Anti;
        metrics_mt{iS}(iD).AccuracyMeanSE_ProMinusAnti = metrics_mt{iS}(iD).AccuracyMeanSE_Pro - metrics_mt{iS}(iD).AccuracyMeanSE_Anti;

        % --- calculating mean, std, SE, count for saccade type x congruency
        % metrics_mt{iS}(iD).Accuracy_Pro_Cong = getDescriptiveStats(metrics_mt{iS}(iD).Accuracy_Pro_Cong, tmpProCongAcc);
        % metrics_mt{iS}(iD).RT_Pro_Cong = getDescriptiveStats(metrics_mt{iS}(iD).RT_Pro_Cong, tmpProCongRT);
        % metrics_mt{iS}(iD).Accuracy_Anti_Cong = getDescriptiveStats(metrics_mt{iS}(iD).Accuracy_Anti_Cong, tmpAntiCongAcc);
        % metrics_mt{iS}(iD).RT_Anti_Cong = getDescriptiveStats(metrics_mt{iS}(iD).RT_Anti_Cong, tmpAntiCongRT);
        metrics_mt{iS}(iD).Accuracy_Cong_Combined = getDescriptiveStats(metrics_mt{iS}(iD).Accuracy_Cong_Combined, tmpCongAcc_Combined);
        metrics_mt{iS}(iD).RT_Cong_Combined = getDescriptiveStats(metrics_mt{iS}(iD).RT_Cong_Combined, tmpCongRT_Combined);


        % --- --- --- --- --- --- --- --- --- --- ---
        % --- Filling metrics_mt with CR statistics
        % --- --- --- --- --- --- --- --- --- --- ---

        metrics_mt{iS}(iD).RT_NumStim = NaN(length(iConditions_StimInTrial), 4);
        metrics_mt{iS}(iD).Acc_NumStim = NaN(length(iConditions_StimInTrial), 4);
        metrics_mt{iS}(iD).ChosenObjectCategory = NaN(length(iConditions_ChosenObjectCategory), 1);
        metrics_mt{iS}(iD).AvgTrialsToError = NaN(1, 4);
        metrics_mt{iS}(iD).TrialsToError = [];
        metrics_mt{iS}(iD).ChosenObjectIndex = {};
        metrics_mt{iS}(iD).nBack = {};
        

        % --- tmp variables - initialization

        tmpRT_NumStim = NaN(length(iConditions_StimInTrial), res_mt{iS}(iD).nTrials_cr);
        tmpAcc_NumStim = NaN(length(iConditions_StimInTrial), res_mt{iS}(iD).nTrials_cr);
        tmpChosenObjectCategory = NaN(length(iConditions_ChosenObjectCategory), res_mt{iS}(iD).nTrials_cr);
        tmpAvgTrialsToError = NaN(1, res_mt{iS}(iD).nTrials_cr);
        tmpErrorStimulus = NaN(1, res_mt{iS}(iD).nTrials_cr);

        % --- populating tmp structures
        
        PCCount = 0;
        NewCount = 0;
        PNCCount = 0;
        for iT = 1:res_mt{iS}(iD).nTrials_cr
            % --- New, PC, or PNC
            if isequal(res_mt{iS}(iD).ChosenObjectCategory(iT), iConditions_ChosenObjectCategory(1))
                PCCount = PCCount + 1;
            elseif isequal(res_mt{iS}(iD).ChosenObjectCategory(iT), iConditions_ChosenObjectCategory(2))
                NewCount = NewCount + 1;
            elseif isequal(res_mt{iS}(iD).ChosenObjectCategory(iT), iConditions_ChosenObjectCategory(3))
                PNCCount = PNCCount + 1;
            end

            % --- Avg trials to error
            if (iT + 1) > res_mt{iS}(iD).nTrials_cr || res_mt{iS}(iD).TrialCount_InBlock(iT + 1) == 1
                tmpAvgTrialsToError(1, iT) = res_mt{iS}(iD).TrialCount_InBlock(iT);
            end


            % --- # stim
            for iT = 1:length(res_mt{iS}(iD).CurrentTrialStims)
                trialStimString = res_mt{iS}(iD).CurrentTrialStims{iT};
                tmpstr = trialStimString(2:end-1);
                stimElements = strsplit(tmpstr, ',');
                NumStimInTrial(iT) = length(stimElements);
            
                for i = 1:length(iConditions_StimInTrial)
                    if NumStimInTrial(iT) == iConditions_StimInTrial(i)
                        tmpAcc_NumStim(i, iT) = res_mt{iS}(iD).Accuracy(iT);
                        tmpRT_NumStim(i, iT) = res_mt{iS}(iD).ReactionTime(iT);
                    end
                end
            end


        end


        for i = 1:numel(res_mt{iS}(iD).ObjectIndexAtError)
            % disp(numel(res(iD).ObjectIndexAtError));
            % disp(res(iD).ObjectIndexAtError{i});
            tmpTTE = res_mt{iS}(iD).ObjectIndexAtError{i}{3};
            tmpErrorObj = res_mt{iS}(iD).ObjectIndexAtError{i}{1};
            tmpBlockCount = res_mt{iS}(iD).ObjectIndexAtError{i}{2};


            for iT = 1:res_mt{iS}(iD).nTrials_cr
                if tmpBlockCount == res_mt{iS}(iD).BlockCount(iT)
                    %disp(res(iD).CurrentTrialStims{iT});
                    if contains(res_mt{iS}(iD).CurrentTrialStims{iT}, num2str(tmpErrorObj))
                        tmpTrialOfFirstAppearance = res_mt{iS}(iD).TrialInBlock(iT);
                        break
                    end
                end
                %fprintf_('first app: %d\n', tmpTrialOfFirstAppearance);
                %break
            end
            metrics_mt{iS}(iD).nBack{end+1} = {tmpTTE - tmpTrialOfFirstAppearance, tmpTTE, tmpTrialOfFirstAppearance};
            % fprintf_('difference: %d; ', metrics_mt{iS}(iD).nBack{end}{1}); %tmpTTE - tmpTrialOfFirstAppearance);
            % fprintf_('tte: %d; ', metrics_mt{iS}(iD).nBack{end}{2});
            % fprintf_('first app: %d\n', metrics_mt{iS}(iD).nBack{end}{3});
        %break
        end

        % --- populating metrics_mt
        metrics_mt{iS}(iD).ChosenObjectCategory(1,1) = PCCount;
        metrics_mt{iS}(iD).ChosenObjectCategory(2,1) = NewCount;
        metrics_mt{iS}(iD).ChosenObjectCategory(3,1) = PNCCount;

        metrics_mt{iS}(iD).Acc_NumStim = getDescriptiveStats(metrics_mt{iS}(iD).Acc_NumStim, tmpAcc_NumStim);
        metrics_mt{iS}(iD).RT_NumStim = getDescriptiveStats(metrics_mt{iS}(iD).RT_NumStim, tmpRT_NumStim);

        metrics_mt{iS}(iD).AvgTrialsToError = getDescriptiveStats(metrics_mt{iS}(iD).AvgTrialsToError, tmpAvgTrialsToError);
        metrics_mt{iS}(iD).TrialsToError = tmpAvgTrialsToError;

        
        % --- --- --- --- --- --- --- --- --- --- ---
        % --- Filling metrics_mt with FL statistics
        % --- --- --- --- --- --- --- --- --- --- ---


        metrics_mt{iS}(iD).subject_fl = [];
        metrics_mt{iS}(iD).dataset = [];
        metrics_mt{iS}(iD).blocknum_fl = [];
        metrics_mt{iS}(iD).blockID_fl = [];
        metrics_mt{iS}(iD).blockbeginend_fl = [];
        metrics_mt{iS}(iD).learningCurve_fl = [];
    
        metrics_mt{iS}(iD).blockTransition_fl = []; % ED/ID,NEW/OLD
        metrics_mt{iS}(iD).tokenCondition_fl = []; %G2,3, L1,3
    
        metrics_mt{iS}(iD).trialsToCriterion_fl = [];
        metrics_mt{iS}(iD).plateauAccuracy_fl   = [];
    
        metrics_mt{iS}(iD).perseverationsNlabel_fl = [];
        metrics_mt{iS}(iD).perseverationsN_fl = [];
		
		metrics_mt{iS}(iD).RT_fl = [];
		metrics_mt{iS}(iD).plateauRT_fl   = [];
		metrics_mt{iS}(iD).learningCurveRT_fl = [];
		metrics_mt{iS}(iD).learningCurveRTRaw_fl = [];

        % --- --- --- --- --- --- --- --- --- --- ---
        % --- Filling metrics_mt with WM statistics
        % --- --- --- --- --- --- --- --- --- --- ---

        metrics_mt{iS}(iD).subject_wm = [];
        metrics_mt{iS}(iD).conditions_nDistr_delays_wm = iConditions_wm;
        metrics_mt{iS}(iD).conditions_PSD_delays_wm = iConditions2_wm;

        %fprintf(metrics_mt{iS}(iD).conditions_nDistr_delays_wm);

        metrics_mt{iS}(iD).allTrials_wm = {};
        metrics_mt{iS}(iD).allTrials2_wm = {};
        % --- averages
        metrics_mt{iS}(iD).accuracyMeanSE_wm = [];
        metrics_mt{iS}(iD).RT_MeanSE_wm = [];
        metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm = [];
        metrics_mt{iS}(iD).RT_MeanSE_LowTDS_wm = [];
        metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm = [];
        metrics_mt{iS}(iD).RT_MeanSE_HighTDS_wm = [];
		metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm = [];
		metrics_mt{iS}(iD).RT_MeanSE_3dist_wm = []; % <-- ADDED
		metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm = [];
		metrics_mt{iS}(iD).RT_MeanSE_2dist_wm = []; % <-- ADDED
		metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm = [];
		metrics_mt{iS}(iD).RT_MeanSE_noPostSampleDist_wm = []; % <-- ADDED
		metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm = [];
		metrics_mt{iS}(iD).RT_MeanSE_yesPostSampleDist_wm = []; % <-- ADDED


        if isempty(metrics_mt{iS}(iD).subject_wm) & ~isempty(res_mt{iS}(iD).SubjectID_wm)
            metrics_mt{iS}(iD).subject_wm = res_mt{iS}(iD).SubjectID_wm{1};
        end

        % --- --- --- --- --- --- --- --- ---
        % --- detemrine the delays used in this session:
        % --- --- --- --- --- --- --- --- ---
        res_mt{iS}(iD).delayDurationOrig_wm = res_mt{iS}(iD).delayDuration_wm;
        res_mt{iS}(iD).delayDuration_wm = round(res_mt{iS}(iD).delayDuration_wm .* 1000)/1000;
        for iTD=1:length(tmpDelays)
            sel = find( abs(res_mt{iS}(iD).delayDuration_wm - tmpDelays(iTD))<0.05 );
            res_mt{iS}(iD).delayDuration_wm(sel) = tmpDelays(iTD);
        end

    % --- collect all trial outcomes for each combination of nDistr x Delay
    for iM = 1:size(metrics_mt{iS}(iD).conditions_nDistr_delays_wm, 1)
        %disp(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,1))
        %disp(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,2))
        s1 = find(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,1) == res_mt{iS}(iD).nDistractors_wm);
        s2 = find(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,2) == res_mt{iS}(iD).delayDuration_wm);
        %disp(s1)
        %disp(s2)
        [sel, b, c] = intersect(s1, s2);
    
        %disp('First few rows of TDsharedFeatures_wm:')
        %disp(res_mt{iS}(iD).TDsharedFeatures_wm(1:10, :))


        if isempty(sel), continue, end
        if length(metrics_mt{iS}(iD).allTrials_wm) < iM
            %fprintf('iM: %d | length(metrics_mt{iS}(iD).allTrials_wm): %d\n', iM, length(metrics_mt{iS}(iD).allTrials_wm));
            metrics_mt{iS}(iD).allTrials_wm{iM} = [];
        else
            %fprintf('else: iM: %d | length(metrics_mt{iS}(iD).allTrials_wm): %d\n', iM, length(metrics_mt{iS}(iD).allTrials_wm));
        end
        

        newRow = [res_mt{iS}(iD).Outcome_wm(sel)' ...
                  res_mt{iS}(iD).ReactionTime_wm(sel)' ...
                  repmat(iD, length(sel), 1) ...
                  res_mt{iS}(iD).TDsharedFeatures_wm(sel, 1:metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,1))];
    
        %disp(res_mt{iS}(iD).TDsharedFeatures_wm(sel, 1:metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,1)))
        %fprintf(res_mt{iS}(iD).TDsharedFeatures_wm);
        % Append to the existing data
        metrics_mt{iS}(iD).allTrials_wm{iM} = [metrics_mt{iS}(iD).allTrials_wm{iM}; newRow];
        %fprintf(metrics_mt{iS}(iD).allTrials_wm{iM})

        % disp('TDsharedFeatures_wm(sel, 1):')
        % disp(res_mt{iS}(iD).TDsharedFeatures_wm(sel, 1))
        % disp('sel size:')
        % disp(size(sel))
        % disp('Size of TDsharedFeatures_wm:')
        % disp(size(res_mt{iS}(iD).TDsharedFeatures_wm))

    end

    for iC = 1:size(metrics_mt{iS}(iD).conditions_PSD_delays_wm, 1)
        %disp(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,1))
        %disp(metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM,2))
        s1 = find(metrics_mt{iS}(iD).conditions_PSD_delays_wm(iC,1) == res_mt{iS}(iD).postSampleDist_wm);
        s2 = find(metrics_mt{iS}(iD).conditions_PSD_delays_wm(iC,2) == res_mt{iS}(iD).delayDuration_wm);
        %disp(s1)
        %disp(s2)
        [sel, b, c] = intersect(s1, s2);
    
        %disp('First few rows of TDsharedFeatures_wm:')
        %disp(res_mt{iS}(iD).TDsharedFeatures_wm(1:10, :))


        if isempty(sel), continue, end
        if length(metrics_mt{iS}(iD).allTrials2_wm) < iC
            %fprintf('iM: %d | length(metrics_mt{iS}(iD).allTrials_wm): %d\n', iM, length(metrics_mt{iS}(iD).allTrials_wm));
            metrics_mt{iS}(iD).allTrials2_wm{iC} = [];
        else
            %fprintf('else: iM: %d | length(metrics_mt{iS}(iD).allTrials_wm): %d\n', iM, length(metrics_mt{iS}(iD).allTrials_wm));
        end

        newRow = [res_mt{iS}(iD).Outcome_wm(sel)' ...
                  res_mt{iS}(iD).ReactionTime_wm(sel)' ...
                  repmat(iD, length(sel), 1) ...
                  res_mt{iS}(iD).TDsharedFeatures_wm(sel, 1:metrics_mt{iS}(iD).conditions_PSD_delays_wm(iC,1))];
    

        % Append to the existing data
        metrics_mt{iS}(iD).allTrials2_wm{iC} = [metrics_mt{iS}(iD).allTrials2_wm{iC}; newRow];
        %fprintf(metrics_mt{iS}(iD).allTrials_wm{iM})


    end
        
    end

    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- Further FL Analysis
    % --- --- --- --- --- --- --- --- --- --- --- ---

    for iD = 1:length(res_mt{iS})

        % --- reconstruct block tansition type and Token condition per block
		if isempty(res_mt{iS}(iD).dataset)
            continue
		end
        
        
        metrics_mt{iS}(iD).dataset = res_mt{iS}(iD).dataset;
		
		% Split the string by the underscore delimiter
		parts = split(res_mt{iS}(iD).dataset, '_');
		
		% Get the last element from the resulting cell array
		last_part = parts{end};
		
		% Assign it to your metrics structure
		metrics_mt{iS}(iD).SubjectID_fl = last_part;

		if isempty(res_mt{iS}(iD).BlockNum_fl)
            continue
		end
		% metrics_mt{iS}(iD).subject_fl = res_mt{iS}(iD).SubjectID_fl{1};
		
        blockStarts = find([1 diff(res_mt{iS}(iD).BlockNum_fl)]);

        for j=1:length(blockStarts)

            % --- find indices for trials in current block
            if j == length(blockStarts)
                idx = blockStarts(j):length(res_mt{iS}(iD).BlockNum_fl);
                metrics_mt{iS}(iD).block_fl(j,1:3) = [res_mt{iS}(iD).BlockNum_fl(blockStarts(j)) blockStarts(j) length(res_mt{iS}(iD).BlockNum_fl)];
            else
                idx = blockStarts(j): blockStarts(j+1)-1;
                metrics_mt{iS}(iD).block_fl(j,1:3) = [res_mt{iS}(iD).BlockNum_fl(blockStarts(j)) blockStarts(j) blockStarts(j+1)-1];
            end

            metrics_mt{iS}(iD).blocknum_fl(j) = j;
            metrics_mt{iS}(iD).blockID_fl{j} = res_mt{iS}(iD).TrialID_fl{idx(1)};

            % --- --- --- --- --- --- ---
            % --- When it is not the first block of a session,
            % --- identify intra- versus extra-dimensional transitions and
            % --- shifts to new object set or same object set as previous block
            % --- --- --- --- --- --- ---
            icndstring = '';
            if j == 1,
                metrics_mt{iS}(iD).blockTransition_fl{j} = 'First';
                if j < length(blockStarts)
                    metrics_mt{iS}(iD).blockbeginend_fl(j,1:2) = [blockStarts(j) blockStarts(j+1)-1];
                else
                    % Handle the last block safely
                    metrics_mt{iS}(iD).blockbeginend_fl(j,1:2) = [blockStarts(j) length(res_mt{iS}(iD).BlockNum_fl)];
                end


            else
                % --- previous and current block
                idx_oldbl = blockStarts(j-1);
                idx_newbl = blockStarts(j);
                if j== length(blockStarts),
                    idx_blockend = length(res_mt{iS}(iD).BlockNum_fl);
                else
                    idx_blockend = blockStarts(j+1);
                end
                metrics_mt{iS}(iD).blockbeginend_fl(j,1:2) = [idx_newbl idx_blockend];

                % --- collect all vis features shown in previous and current block
                features_previousBlock = [];
                for m=idx_oldbl:idx_newbl-1
                    if isempty(res_mt{iS}(iD).distractorVectors_fl{m}), res_mt{iS}(iD).distractorVectors_fl{m} = {NaN, NaN}; end
                    features_previousBlock= [features_previousBlock [find(res_mt{iS}(iD).targetObjectVector_fl(m,:)) find(res_mt{iS}(iD).distractorVectors_fl{m}{1}) find(res_mt{iS}(iD).distractorVectors_fl{m}{2})]];
                end
                features_currentBlock = [];
                numTrials = length(res_mt{iS}(iD).targetObjectVector_fl);  % Get valid max index
                
                for m = idx_newbl:idx_blockend
                    if m > numTrials  % Prevent out-of-bounds access
                        warning('Skipping m=%d because it exceeds valid index range (1 to %d)', m, numTrials);
                        break;  % Stop the loop if m exceeds the valid index range
                    end
                    
                    if m <= length(res_mt{iS}(iD).distractorVectors_fl)
                        if isempty(res_mt{iS}(iD).distractorVectors_fl{m}), res_mt{iS}(iD).distractorVectors_fl{m} = {NaN, NaN}; end
                        features_currentBlock = [features_currentBlock, [find(res_mt{iS}(iD).targetObjectVector_fl(m,:)), ...
                                                                         find(res_mt{iS}(iD).distractorVectors_fl{m}{1}), ...
                                                                         find(res_mt{iS}(iD).distractorVectors_fl{m}{2})]];
                    else
                        res_mt{iS}(iD).distractorVectors_fl{m} = {NaN, NaN};
                        features_currentBlock = [];
                    end
                end

                FEATURESPREV = unique(features_previousBlock);
                FEATURESNEW = unique(features_currentBlock);
                [a,b] = ismember(FEATURESNEW,FEATURESPREV);
                res_mt{iS}(iD).featuresShown_fl{j}{1} = FEATURESPREV;
                res_mt{iS}(iD).featuresShown_fl{j}{2} = FEATURESNEW;

                if idx_oldbl <= length(res_mt{iS}(iD).TargetFeature_fl)
                    TargetFeature_old = res_mt{iS}(iD).TargetFeature_fl(idx_oldbl);
                else
                    TargetFeature_old = NaN;
                end
                if idx_newbl <= length(res_mt{iS}(iD).TargetFeature_fl)
                    TargetFeature_new = res_mt{iS}(iD).TargetFeature_fl(idx_newbl);
                else
                    TargetFeature_new = NaN;
                end
                % --- check that the target feature is different
                if TargetFeature_new == TargetFeature_old
                    disp('target feature stayed same in new block')
                    % continue,
                    % error('target feature stayed same in new block')
                end

                TargetDimension_old = [];
                for k=1:length(res_mt{iS}(1).dimensionNums), if ismember(TargetFeature_old,res_mt{iS}(1).dimensionNums{k}), TargetDimension_old=k; end, end
                TargetDimension_new = [];
                for k=1:length(res_mt{iS}(1).dimensionNums), if ismember(TargetFeature_new,res_mt{iS}(1).dimensionNums{k}), TargetDimension_new=k; end, end

                % --- new block has same targetDimension (
                if TargetDimension_new == TargetDimension_old
                    icndstring = [icndstring 'ID.'];
                else
                    icndstring = [icndstring 'ED.'];
                end
                %if ~isempty(findstr(res.TrialID{idx_newbl},'Same')), disp('www'), return, end

                % --- target object differs to both previous distractors
                if sum(res_mt{iS}(iD).targetObjectVector_fl(idx_newbl,:)~=res_mt{iS}(iD).distractorVectors_fl{idx_oldbl}{1})        > 0 ...
                        | sum(res_mt{iS}(iD).targetObjectVector_fl(idx_newbl,:)~=res_mt{iS}(iD).distractorVectors_fl{idx_oldbl}{2}) > 0
                    icndstring = [icndstring 'NEW'];
                else
                    icndstring = [icndstring 'OLD'];
                end
                metrics_mt{iS}(iD).blockTransition_fl{j} = icndstring;
            end

            % --- --- --- --- --- --- ---
            % --- Identify token condition
            % --- --- --- --- --- --- ---
            iToken = unique(res_mt{iS}(iD).Outcome_fl(idx));
            metrics_mt{iS}(iD).tokenCondition_fl{j} = sprintf('L%dG%d',iToken);

            % --- --- --- --- --- --- --- --- --- --- ---
            % --- get 'trial-to-criterion' = learning speed
            % --- --- --- --- --- --- --- --- --- --- ---
            metrics_mt{iS}(iD).trialsToCriterion_fl(j,1:3) = [NaN NaN NaN];
            metrics_mt{iS}(iD).plateauAccuracy_fl(j,1:3) = [NaN NaN NaN];
            metrics_mt{iS}(iD).learningCurve_fl{j} =[];
			
			 % --- START: ADDED FOR RT ---
        	metrics_mt{iS}(iD).plateauRT_fl(j,1:3) = [NaN NaN NaN];
        	metrics_mt{iS}(iD).learningCurveRT_fl{j} =[];
        	metrics_mt{iS}(iD).learningCurveRTRaw_fl{j} =[];
        	% --- END: ADDED FOR RT ---


            idxWith5Prev = [idx(1)-5:idx(1)-1 idx];
            idxWith5Prev(idxWith5Prev<1)=[];

            nTrialWindow            = 10;
            accuracyThreshold       = 0.7; % for individual blocks
            accuracyForwardSmoothed = [];% for visualization the first two trials in a ablock should not be smoothed
            accuracyForwardSmoothedThr = []; % for threshold computation all is smoothed to avoud wrong conclusion from '1' in first trial
            if idx <= length(res_mt{iS}(iD).Accuracy_fl)
                iData = res_mt{iS}(iD).Accuracy_fl(idx);
            else
                iData = NaN;
			end


			% --- START: Added for RT ---
        	% Handle RT data, padding with NaN if shorter than Accuracy data
        	iDataRT = NaN(1, length(idx));
        	num_rts = length(res_mt{iS}(iD).ReactionTime_fl);
        	valid_idx_for_rt = idx(idx <= num_rts);
        	if ~isempty(valid_idx_for_rt)
             	block_indices = find(ismember(idx, valid_idx_for_rt));
             	iDataRT(block_indices) = res_mt{iS}(iD).ReactionTime_fl(valid_idx_for_rt);
        	end
        	metrics_mt{iS}(iD).RT_fl = [metrics_mt{iS}(iD).RT_fl, iDataRT];
        	% --- END: Added for RT ---



            for k = 1:length(iData),
                accuracyForwardSmoothedThr(k) = nanmean(iData( k:min([length(iData),k+nTrialWindow-1])));
                if k>2
                    accuracyForwardSmoothed(k) = nanmean(iData( k:min([length(iData),k+nTrialWindow-1])));
                    % no smoothing for first two trials
                    %elseif k>2 & k<=4
                    %    accuracyForwardSmoothed(k) = nanmean(iData( k:min([length(iData),k+3-1])));
                else
                    accuracyForwardSmoothed(k) = nanmean(iData( k:min([length(iData),k+1-1])));
                end
            end
            if length(accuracyForwardSmoothedThr)>6,
                tmpLP= min(find(accuracyForwardSmoothedThr >= accuracyThreshold));
                if isempty(tmpLP),
                    metrics_mt{iS}(iD).trialsToCriterion_fl(j,1:3) = [NaN max(accuracyForwardSmoothedThr(5:end)), nanstd(accuracyForwardSmoothedThr(5:end))];
                    metrics_mt{iS}(iD).plateauAccuracy_fl(j,1:3) = [nanmean(iData) nanstd(iData)  length(iData)];
                else
                    metrics_mt{iS}(iD).trialsToCriterion_fl(j,1:3) = [tmpLP(1) max(accuracyForwardSmoothedThr(tmpLP(1):end)), nanstd(accuracyForwardSmoothedThr(tmpLP(1):end))];
                    metrics_mt{iS}(iD).plateauAccuracy_fl(j,1:3) = [nanmean(iData(tmpLP+1:end))  nanstd(iData(tmpLP+1:end)) length(iData)];
                end
                % --- from here on we use the smoothed version with trl 1 + 2 raw
                iPreDataSmoothed=[];
                iWithPreData = fliplr(res_mt{iS}(iD).Accuracy_fl(idxWith5Prev(1:5)));
                for k = 1:length(iWithPreData), iPreDataSmoothed(k) = nanmean(iWithPreData( k:min([length(iWithPreData), k+nTrialWindow-1]))); end

                if j <= length(res_mt{iS}(iD).Accuracy_fl)
                    metrics_mt{iS}(iD).learningCurveRaw_fl{j} = [res_mt{iS}(iD).Accuracy_fl(idxWith5Prev)];
                    metrics_mt{iS}(iD).learningCurve_fl{j} = [fliplr(iPreDataSmoothed) accuracyForwardSmoothed  ];
                else
                    metrics_mt{iS}(iD).learningCurveRaw_fl{j} = NaN;
                    metrics_mt{iS}(iD).learningCurve_fl{j} = NaN;
                    %fprintf_('bad dataset %d, j = %d, len = %d\n', iD, j, length(res(iD).Accuracy));
				end

				 % --- START: Added for RT ---
            	% --- RT Learning Curve processing
            	iPreDataRTSmoothed=[];
            	
            	% Get RT data for the pre-block window + current block
            	rt_full_window = NaN(1, length(idxWith5Prev));
            	valid_window_indices = idxWith5Prev(idxWith5Prev <= num_rts);
            	if ~isempty(valid_window_indices)
                	rt_full_window(ismember(idxWith5Prev, valid_window_indices)) = res_mt{iS}(iD).ReactionTime_fl(valid_window_indices);
            	end
            	metrics_mt{iS}(iD).learningCurveRTRaw_fl{j} = rt_full_window;
	
            	% Smooth RT data
            	rt_pre_data = rt_full_window(1:5);
            	rt_block_data = rt_full_window(6:end);
            	
            	iWithPreDataRT_flipped = fliplr(rt_pre_data);
            	for k = 1:length(iWithPreDataRT_flipped), iPreDataRTSmoothed(k) = nanmean(iWithPreDataRT_flipped( k:min([length(iWithPreDataRT_flipped), k+nTrialWindow-1]))); end
	
            	rtForwardSmoothed = [];
            	for k = 1:length(rt_block_data),
                	rtForwardSmoothed(k) = nanmean(rt_block_data( k:min([length(rt_block_data),k+nTrialWindow-1])));
            	end
            	
            	metrics_mt{iS}(iD).learningCurveRT_fl{j} = [fliplr(iPreDataRTSmoothed) rtForwardSmoothed];
            	% --- END: Added for RT ---


            end

            % --- --- --- --- --- --- --- --- --- --- ---
            % --- CEn analysis of perseveration
            % --- --- --- --- --- --- --- --- --- --- ---
            if idx <= length(res_mt{iS}(iD).Accuracy_fl)
                iData = res_mt{iS}(iD).Accuracy_fl(idx);
                iData = [NaN NaN iData NaN NaN NaN ];
                %fprintf_('idx (%d) not out of bounds (%d)\n', idx, length(res(iD).Accuracy));
            else
                iData = NaN;
                iData = [NaN NaN iData NaN NaN NaN ];
                %fprintf_('idx (%d) out of bounds (%d). NaN-ing idx %d from dataset %d\n', idx, length(res(iD).Accuracy), idx, iD);
            end
            metrics_mt{iS}(iD).perseverationsNlabel_fl={'CEC','CEn','CEEC','CEEEC','CEEEn'};
            iErr = find(iData==0);
            metrics_mt{iS}(iD).perseverationsN_fl(j,1:7) = [zeros(1,7)];
            for k=1:length(iErr)
                prev = iData(iErr(k)-1);
                n1 = iData(iErr(k)+1);
                n2 = iData(iErr(k)+2);
                n3 = iData(iErr(k)+3);
                % --- CEC
                % --- CEn (perseveration in general)
                % --- CEEC (perseveration)
                % --- CEEEC (perseveration)
                % --- CEEEn (perseveration)
                % --- CEEEE (perseveration)
                metrics_mt{iS}(iD).perseverationsN_fl(j,1:5) = metrics_mt{iS}(iD).perseverationsN_fl(j,1:5) + ...
                    [ length(find(prev==1 & iData(iErr(k))==0 & n1==1 )) ...
                    length(find(prev==1 & iData(iErr(k))==0 & n1==0 )) ...
                    length(find(prev==1 & iData(iErr(k))==0 & n1==0 & n2==1 )) ...
                    length(find(prev==1 & iData(iErr(k))==0 & n1==0 & n2==0  & n3==1 )) ...
                    length(find(prev==1 & iData(iErr(k))==0 & n1==0 & n2==0  & n3==0 ))];
            end
            metrics_mt{iS}(iD).perseverationsN_fl(j,6) = length(iErr);
            metrics_mt{iS}(iD).perseverationsN_fl(j,7) = length(find(~isnan(iData)));
        end
        %disp('determined block transitions, token conditions, computed learning speed and pers errors. '),
    %end




        if isempty(metrics_mt{iS}(iD).blockID_fl), continue, end

    % iD = 1;
    % fl(iD).blockID'
    % fl(iD).blockTransition
    cndLabels = {'ID','ED','SAME','NEW', 'L-3', 'L-1', 'G2', 'G4'};

    % idx_cnd1 = (strcmp(fl(iD).blockTransition,'ID.OLD') | strcmp(fl(iD).blockTransition,'ID.NEW'));
    % idx_cnd2 = (strcmp(fl(iD).blockTransition,'ED.OLD') | strcmp(fl(iD).blockTransition,'ED.NEW'));
    idx_cnd1 = (strncmp(metrics_mt{iS}(iD).blockID_fl,'IDSame',5));
    idx_cnd2 = (strncmp(metrics_mt{iS}(iD).blockID_fl,'EDSame',5));
    idx_all = [idx_cnd1(:)' | idx_cnd2(:)'];

    idx_cnd3 = (strncmp(metrics_mt{iS}(iD).blockID_fl,'IDSame',5) | strncmp(metrics_mt{iS}(iD).blockID_fl,'EDSame',5));
    idx_cnd4 = (strncmp(metrics_mt{iS}(iD).blockID_fl,'IDNew',5) | strncmp(metrics_mt{iS}(iD).blockID_fl,'EDNew',5));

    % {'L-1G2'}    {'L-1G4'}    {'L-3G2'}    {'L-3G4'}
    % unique(fl(iD).tokenCondition)
    idx_cnd5 = (strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-3G2') | strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-3G4'));
    idx_cnd6 = (strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-1G2') | strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-1G4'));
    idx_cnd7 = (strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-1G2') | strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-3G2'));
    idx_cnd8 = (strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-1G4') | strcmp(metrics_mt{iS}(iD).tokenCondition_fl,'L-3G4'));


    % --- --- --- --- --- --- --- --- --- ---
    % --- Switch costs per condition (ED vs ID)
    % ---- for learning point (LP) and plateau perf.
    % --- --- --- --- --- --- --- --- --- ---
    metrics_mt{iS}(iD).SwitchCosts_label_fl = {'All','ID','ED','SAME','NEW', 'L-3', 'L-1', 'G2', 'G4'};
    metrics_mt{iS}(iD).SwitchCosts_LP_fl = [];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(1,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_all,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_all,1))./sqrt(length(idx_all))];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(2,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd1,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd1,1))./sqrt(length(idx_cnd1))];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(3,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd2,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd2,1))./sqrt(length(idx_cnd2))];

    metrics_mt{iS}(iD).SwitchCosts_LP_fl(6,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd5,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd5,1))./sqrt(length(idx_cnd5))];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(7,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd6,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd6,1))./sqrt(length(idx_cnd6))];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(8,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd7,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd7,1))./sqrt(length(idx_cnd7))];
    metrics_mt{iS}(iD).SwitchCosts_LP_fl(9,1:2) = [nanmean(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd8,1),1) nanstd(metrics_mt{iS}(iD).trialsToCriterion_fl(idx_cnd8,1))./sqrt(length(idx_cnd8))];

    metrics_mt{iS}(iD).SwitchCosts_Accuracy = [];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(1,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_all,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_all,1))./sqrt(length(idx_all))];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(2,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd1,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd1,1))./sqrt(length(idx_cnd1))];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(3,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd2,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd2,1))./sqrt(length(idx_cnd2))];

    metrics_mt{iS}(iD).SwitchCosts_Accuracy(6,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd5,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd5,1))./sqrt(length(idx_cnd5))];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(7,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd6,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd6,1))./sqrt(length(idx_cnd6))];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(8,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd7,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd7,1))./sqrt(length(idx_cnd7))];
    metrics_mt{iS}(iD).SwitchCosts_Accuracy(9,1:2) = [nanmean(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd8,1),1) nanstd(metrics_mt{iS}(iD).plateauAccuracy_fl(idx_cnd8,1))./sqrt(length(idx_cnd8))];
	
	    % --- START: Added for RT ---
    metrics_mt{iS}(iD).SwitchCosts_RT = [];
    metrics_mt{iS}(iD).SwitchCosts_RT(1,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_all,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_all,1))./sqrt(sum(idx_all))];
    metrics_mt{iS}(iD).SwitchCosts_RT(2,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd1,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd1,1))./sqrt(sum(idx_cnd1))];
    metrics_mt{iS}(iD).SwitchCosts_RT(3,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd2,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd2,1))./sqrt(sum(idx_cnd2))];
    metrics_mt{iS}(iD).SwitchCosts_RT(6,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd5,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd5,1))./sqrt(sum(idx_cnd5))];
    metrics_mt{iS}(iD).SwitchCosts_RT(7,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd6,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd6,1))./sqrt(sum(idx_cnd6))];
    metrics_mt{iS}(iD).SwitchCosts_RT(8,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd7,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd7,1))./sqrt(sum(idx_cnd7))];
    metrics_mt{iS}(iD).SwitchCosts_RT(9,1:2) = [nanmean(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd8,1),1) nanstd(metrics_mt{iS}(iD).plateauRT_fl(idx_cnd8,1))./sqrt(sum(idx_cnd8))];
    % --- END: Added for RT ---

    % --- --- --- --- --- --- --- --- --- ---
    % --- Avg. learning curves for each condition (ED vs ID)
    % --- --- --- --- --- --- --- --- --- ---
    iX = -4:30; %(5 trials before first trial in block)
    LCurve_tmp = nan(length(idx_cnd1),length(iX));
    for j=1:length(metrics_mt{iS}(iD).learningCurve_fl)
        if isempty(metrics_mt{iS}(iD).learningCurve_fl{j}), continue, end
        imax = min([length(iX) length(metrics_mt{iS}(iD).learningCurve_fl{j})]) ;
        LCurve_tmp(j,1:imax) = metrics_mt{iS}(iD).learningCurve_fl{j}(1: imax);
    end
	
	 % --- START: Added for RT ---
    LCurve_RT_tmp = nan(length(metrics_mt{iS}(iD).learningCurveRT_fl), length(iX));
    for j=1:length(metrics_mt{iS}(iD).learningCurveRT_fl)
        if isempty(metrics_mt{iS}(iD).learningCurveRT_fl{j}), continue, end
        imax = min([length(iX) length(metrics_mt{iS}(iD).learningCurveRT_fl{j})]);
        LCurve_RT_tmp(j, 1:imax) = metrics_mt{iS}(iD).learningCurveRT_fl{j}(1:imax);
    end
    % --- END: Added for RT ---

    metrics_mt{iS}(iD).LCurve_label_fl = {'All','ID','ED','SAME','NEW', 'L-3', 'L-1', 'G2', 'G4'};
    metrics_mt{iS}(iD).LCurve_x = iX;
    %metrics_mt{iS}(iD).LCurve_all = [nanmean(LCurve_tmp(idx_all,:),1); nanstd(LCurve_tmp(idx_all,:))./sqrt(length(idx_all))];
    %metrics_mt{iS}(iD).LCurve_cnd1 = [nanmean(LCurve_tmp(idx_cnd1,:),1); nanstd(LCurve_tmp(idx_cnd1,:))./sqrt(length(idx_cnd1))];
    %metrics_mt{iS}(iD).LCurve_cnd2 = [nanmean(LCurve_tmp(idx_cnd2,:),1); nanstd(LCurve_tmp(idx_cnd2,:))./sqrt(length(idx_cnd2))];
	
	% --- START: Added for RT ---
    % Calculate and store average RT learning curves per condition
    % Condition 1
    if sum(idx_cnd1) > 0
        mean_rt_cnd1 = nanmean(LCurve_RT_tmp(idx_cnd1, :), 1);
        if sum(idx_cnd1) <= 1, std_rt_cnd1 = zeros(1, size(LCurve_RT_tmp, 2)); else, std_rt_cnd1 = nanstd(LCurve_RT_tmp(idx_cnd1, :), 1) ./ sqrt(sum(idx_cnd1)); end
        metrics_mt{iS}(iD).LCurve_RT_cnd1 = [mean_rt_cnd1; std_rt_cnd1];
    else, metrics_mt{iS}(iD).LCurve_RT_cnd1 = []; end
    % Condition 2
    if sum(idx_cnd2) > 0
        mean_rt_cnd2 = nanmean(LCurve_RT_tmp(idx_cnd2, :), 1);
        if sum(idx_cnd2) <= 1, std_rt_cnd2 = zeros(1, size(LCurve_RT_tmp, 2)); else, std_rt_cnd2 = nanstd(LCurve_RT_tmp(idx_cnd2, :), 1) ./ sqrt(sum(idx_cnd2)); end
        metrics_mt{iS}(iD).LCurve_RT_cnd2 = [mean_rt_cnd2; std_rt_cnd2];
    else, metrics_mt{iS}(iD).LCurve_RT_cnd2 = []; end
    % (Repeat for conditions 5 through 8 as needed)
    % --- END: Added for RT ---

	
    %condition 1
    if sum(idx_cnd1) > 0
        mean_cnd1 = nanmean(LCurve_tmp(idx_cnd1, :), 1);
    if sum(idx_cnd1) <= 1
        std_cnd1 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd1 = nanstd(LCurve_tmp(idx_cnd1, :), 1) ./ sqrt(sum(idx_cnd1));
    end
    metrics_mt{iS}(iD).LCurve_cnd1 = [mean_cnd1; std_cnd1];
    else
        metrics_mt{iS}(iD).LCurve_cnd1 = [];
    end

    %condition 2
    if sum(idx_cnd2) > 0
        mean_cnd2 = nanmean(LCurve_tmp(idx_cnd2, :), 1);
    if sum(idx_cnd2) <= 1
        std_cnd2 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd2 = nanstd(LCurve_tmp(idx_cnd2, :), 1) ./ sqrt(sum(idx_cnd2));
    end
    metrics_mt{iS}(iD).LCurve_cnd2 = [mean_cnd2; std_cnd2];
    else
        metrics_mt{iS}(iD).LCurve_cnd2 = [];
    end
%     disp('size(LCurve_tmp');
%     disp(size(LCurve_tmp));
%     disp('idx_cnd5');
% disp(idx_cnd5);
% disp('idx_cnd6');
% disp(idx_cnd6);
% disp('idx_cnd7');
% disp(idx_cnd7);
% disp('idx_cnd8');
% disp(idx_cnd8);

mean_cnd6 = nanmean(LCurve_tmp(idx_cnd6, :), 1);
std_cnd6 = nanstd(LCurve_tmp(idx_cnd6, :), 1) ./ sqrt(length(idx_cnd6));
% disp_('size(mean_cnd6)');
% disp_(size(mean_cnd6));
% disp_('size(std_cnd6)');
% disp_(size(std_cnd6));

    % metrics_mt{iS}(iD).LCurve_cnd5 = [nanmean(LCurve_tmp(idx_cnd5,:),1); nanstd(LCurve_tmp(idx_cnd5,:))./sqrt(length(idx_cnd5))];
    % metrics_mt{iS}(iD).LCurve_cnd6 = [nanmean(LCurve_tmp(idx_cnd6,:),1); nanstd(LCurve_tmp(idx_cnd6,:))./sqrt(length(idx_cnd6))];
    % metrics_mt{iS}(iD).LCurve_cnd7 = [nanmean(LCurve_tmp(idx_cnd7,:),1); nanstd(LCurve_tmp(idx_cnd7,:))./sqrt(length(idx_cnd7))];
    % metrics_mt{iS}(iD).LCurve_cnd8 = [nanmean(LCurve_tmp(idx_cnd8,:),1); nanstd(LCurve_tmp(idx_cnd8,:))./sqrt(length(idx_cnd8))];

    % Condition 5
if sum(idx_cnd5) > 0
    mean_cnd5 = nanmean(LCurve_tmp(idx_cnd5, :), 1);
    if sum(idx_cnd5) <= 1
        std_cnd5 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd5 = nanstd(LCurve_tmp(idx_cnd5, :), 1) ./ sqrt(sum(idx_cnd5));
    end
    metrics_mt{iS}(iD).LCurve_cnd5 = [mean_cnd5; std_cnd5];
else
    metrics_mt{iS}(iD).LCurve_cnd5 = [];
end

% Condition 6
if sum(idx_cnd6) > 0
    mean_cnd6 = nanmean(LCurve_tmp(idx_cnd6, :), 1);
    if sum(idx_cnd6) <= 1
        std_cnd6 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd6 = nanstd(LCurve_tmp(idx_cnd6, :), 1) ./ sqrt(sum(idx_cnd6));
    end
    metrics_mt{iS}(iD).LCurve_cnd6 = [mean_cnd6; std_cnd6];
else
    metrics_mt{iS}(iD).LCurve_cnd6 = [];
end

% Condition 7
if sum(idx_cnd7) > 0
    mean_cnd7 = nanmean(LCurve_tmp(idx_cnd7, :), 1);
    if sum(idx_cnd7) <= 1
        std_cnd7 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd7 = nanstd(LCurve_tmp(idx_cnd7, :), 1) ./ sqrt(sum(idx_cnd7));
    end
    metrics_mt{iS}(iD).LCurve_cnd7 = [mean_cnd7; std_cnd7];
else
    metrics_mt{iS}(iD).LCurve_cnd7 = [];
end

% Condition 8
if sum(idx_cnd8) > 0
    mean_cnd8 = nanmean(LCurve_tmp(idx_cnd8, :), 1);
    if sum(idx_cnd8) <= 1
        std_cnd8 = zeros(1, size(LCurve_tmp, 2)); % Set std to 0 if there's only one trial
    else
        std_cnd8 = nanstd(LCurve_tmp(idx_cnd8, :), 1) ./ sqrt(sum(idx_cnd8));
    end
    metrics_mt{iS}(iD).LCurve_cnd8 = [mean_cnd8; std_cnd8];
else
    metrics_mt{iS}(iD).LCurve_cnd8 = [];
end


    % --- --- --- --- --- --- --- --- --- ---
    % --- Perseveration score, normalized by number of blocks
    % --- --- --- --- --- --- --- --- --- ---
    metrics_mt{iS}(iD).iPerseverationsScore = [];
    metrics_mt{iS}(iD).iPerseverationsScore_label = {'All','ID','ED','SAME','NEW', 'L-3', 'L-1', 'G2', 'G4'};
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_all],2) ./ length(find(idx_all));
    metrics_mt{iS}(iD).iPerseverationsScore(1,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd1],2) ./ length(find(idx_cnd1));
    metrics_mt{iS}(iD).iPerseverationsScore(2,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd2],2) ./ length(find(idx_cnd2));
    metrics_mt{iS}(iD).iPerseverationsScore(3,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];

    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd3],2) ./ length(find(idx_cnd3));
    metrics_mt{iS}(iD).iPerseverationsScore(4,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd4],2) ./ length(find(idx_cnd4));
    metrics_mt{iS}(iD).iPerseverationsScore(5,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];


    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd5],2) ./ length(find(idx_cnd5));
    metrics_mt{iS}(iD).iPerseverationsScore(6,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd6],2) ./ length(find(idx_cnd6));
    metrics_mt{iS}(iD).iPerseverationsScore(7,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd7],2) ./ length(find(idx_cnd7));
    metrics_mt{iS}(iD).iPerseverationsScore(8,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];
    iNorm = metrics_mt{iS}(iD).perseverationsN_fl([idx_cnd8],2) ./ length(find(idx_cnd8));
    metrics_mt{iS}(iD).iPerseverationsScore(9,1:2) = [ nanmean( iNorm ) nanstd(iNorm)/sqrt(length(iNorm)) ];

    
    end


    % --- --- --- --- --- --- --- --- --- --- --- ---
    % --- Further WM Analysis
    % --- --- --- --- --- --- --- --- --- --- --- ---
 for iD = 1:length(res_mt{iS})
    if isempty(res_mt{iS}(iD).dataset), continue, end
    
    for iM = 1:size(metrics_mt{iS}(iD).conditions_nDistr_delays_wm,1)
        metrics_mt{iS}(iD).accuracyMeanSE_wm(iM,1:4) = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_wm(iM,1:4) = NaN;
        metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_LowTDS_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_HighTDS_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_3dist_wm(iM,1:4)  = NaN; % <-- ADDED
        metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm(iM,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_2dist_wm(iM,1:4)  = NaN; % <-- ADDED
        
        if iM > length(metrics_mt{iS}(iD).allTrials_wm), continue, end
        if isempty(metrics_mt{iS}(iD).allTrials_wm{iM}), continue, end
        
        tmp = (metrics_mt{iS}(iD).allTrials_wm{iM}(:,1)) > 0;
        metrics_mt{iS}(iD).accuracyMeanSE_wm(iM,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
        
        tmpRT = metrics_mt{iS}(iD).allTrials_wm{iM}(:,2);
        metrics_mt{iS}(iD).RT_MeanSE_wm(iM,1:4) = [nanmean(tmpRT) nanmedian(tmpRT) nanstd(tmpRT)./sqrt(length(tmpRT)) length(tmpRT)];
        
        % Splitting by nDistractors
        nDist_wm = metrics_mt{iS}(iD).conditions_nDistr_delays_wm(iM, 1);
        if nDist_wm == 3
            metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm(iM,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
            metrics_mt{iS}(iD).RT_MeanSE_3dist_wm(iM,1:4) = [nanmean(tmpRT) nanmedian(tmpRT) nanstd(tmpRT)./sqrt(length(tmpRT)) length(tmpRT)]; % <-- ADDED
        elseif nDist_wm == 2
            metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm(iM,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
            metrics_mt{iS}(iD).RT_MeanSE_2dist_wm(iM,1:4) = [nanmean(tmpRT) nanmedian(tmpRT) nanstd(tmpRT)./sqrt(length(tmpRT)) length(tmpRT)]; % <-- ADDED
        else
            disp('nDistractors not equal to 2 or 3 (unexpected!)');
        end
        
        tmpTDmean = nanmean(metrics_mt{iS}(iD).allTrials_wm{iM}(:,4:end),2);
        MMean = mean(nanmean(metrics_mt{iS}(iD).allTrials_wm{iM}(:,4:end)));
        
        selLow = find(tmpTDmean <= MMean);
        tmp = (metrics_mt{iS}(iD).allTrials_wm{iM}(selLow,1)) > 0;
        metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm(iM,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
        metrics_mt{iS}(iD).RT_MeanSE_LowTDS_wm(iM,1:4) = [nanmean(tmpRT(selLow)) nanmedian(tmpRT(selLow)) nanstd(tmpRT(selLow))./sqrt(length(tmpRT(selLow))) length(tmpRT(selLow))];
        
        selHigh = find(tmpTDmean > MMean);
        tmp = (metrics_mt{iS}(iD).allTrials_wm{iM}(selHigh,1)) > 0;
        metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm(iM,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
        metrics_mt{iS}(iD).RT_MeanSE_HighTDS_wm(iM,1:4) = [nanmean(tmpRT(selHigh)) nanmedian(tmpRT(selHigh)) nanstd(tmpRT(selHigh))./sqrt(length(tmpRT(selHigh))) length(tmpRT(selHigh))];
    end
    
    for iC = 1:size(metrics_mt{iS}(iD).conditions_PSD_delays_wm,1)
        metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm(iC,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_noPostSampleDist_wm(iC,1:4)  = NaN; % <-- ADDED
        metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm(iC,1:4)  = NaN;
        metrics_mt{iS}(iD).RT_MeanSE_yesPostSampleDist_wm(iC,1:4)  = NaN; % <-- ADDED
        
        if iC > length(metrics_mt{iS}(iD).allTrials2_wm), continue, end
        if isempty(metrics_mt{iS}(iD).allTrials2_wm{iC}), continue, end
        
        tmp = (metrics_mt{iS}(iD).allTrials2_wm{iC}(:,1)) > 0;
        tmpRT = metrics_mt{iS}(iD).allTrials2_wm{iC}(:,2);
        
        % Splitting by presence of post-sample distractor
        PSD = metrics_mt{iS}(iD).conditions_PSD_delays_wm(iC, 1);
        if PSD == 0
            metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm(iC,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
            metrics_mt{iS}(iD).RT_MeanSE_noPostSampleDist_wm(iC,1:4) = [nanmean(tmpRT) nanmedian(tmpRT) nanstd(tmpRT)./sqrt(length(tmpRT)) length(tmpRT)]; % <-- ADDED
        elseif PSD == 1
            metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm(iC,1:4) = [nanmean(tmp) nanmedian(tmp) nanstd(tmp)./sqrt(length(tmp)) length(tmp)];
            metrics_mt{iS}(iD).RT_MeanSE_yesPostSampleDist_wm(iC,1:4) = [nanmean(tmpRT) nanmedian(tmpRT) nanstd(tmpRT)./sqrt(length(tmpRT)) length(tmpRT)]; % <-- ADDED
        else
            disp('PSD not equal to 0 or 1 (unexpected!)');
        end
    end
end







    fprintf('num datasets for subject %d: %d\n', iS, length(metrics_mt{iS}));

end

        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        % --- save analysis/metrics results in MAT file
        % --- --- --- --- --- --- --- --- --- --- --- --- ---
        save([METRICSFOLDER filesep iResultFileMetrics],'res_mt','metrics_mt','-V7.3');
        disp(sprintf('saved metrics mat-file of n=%d subjects in %s.',length(metrics_mt), iResultFileMetrics));
end

if cfg.do_AnalysisBasicPlot == 1

    % --- --- --- --- --- --- --- --- --- --- ---
    % --- load metrics results if they are not yet loaded
    % --- --- --- --- --- --- --- --- --- --- ---
    if ~exist('metrics_mt')
        load([METRICSFOLDER filesep iResultFileMetrics])
    end
    
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 1: TrialsToError vs ProMinusAnti
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

ASDiffScore = cell(1, numel(cfg.analysisID));
SEASDiffScore = cell(1, numel(cfg.analysisID));
avgTrialsToError = cell(1, numel(cfg.analysisID));
SETrialsToError = cell(1, numel(cfg.analysisID));

x = cell(1, numel(cfg.analysisID));
y = cell(1, numel(cfg.analysisID));
x_err = cell(1, numel(cfg.analysisID));
y_err = cell(1, numel(cfg.analysisID));

colors = lines(numel(cfg.analysisID));

meanX = NaN(1, numel(cfg.analysisID));
meanY = NaN(1, numel(cfg.analysisID));

for iS = 1:numel(cfg.analysisID)

    nSessions = length(metrics_mt{iS});
    ASDiffScore{iS} = NaN(1, nSessions);
    SEASDiffScore{iS} = NaN(1, nSessions);
    avgTrialsToError{iS} = NaN(1, nSessions);
    SETrialsToError{iS} = NaN(1, nSessions);

    for i = 1:nSessions
        % Extract AS accuracy difference scores by session
        ASDiffScore{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_ProMinusAnti(1, 1);
        SEASDiffScore{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_ProMinusAnti(1, 3);
        % Extract CR avg trials to error by session
        avgTrialsToError{iS}(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 1);
        SETrialsToError{iS}(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 3);
    end

    valid = ~isnan(avgTrialsToError{iS}) & ~isnan(ASDiffScore{iS});

    x{iS} = ASDiffScore{iS}(valid); 
    y{iS} = avgTrialsToError{iS}(valid); 
    x_err{iS} = SEASDiffScore{iS}(valid); 
    y_err{iS} = SETrialsToError{iS}(valid); 

    if ~isempty(x{iS})
        meanX(iS) = mean(x{iS});
        meanY(iS) = mean(y{iS});
    end
end

figure;
hold on;

for iS = 1:numel(cfg.analysisID)

    if ~isempty(x{iS})
        errorbar(x{iS}, y{iS}, y_err{iS}, y_err{iS}, x_err{iS}, x_err{iS}, 'o', ...
                 'MarkerSize', 8, 'MarkerEdgeColor', 'none', ... 
                 'MarkerFaceColor', colors(iS, :), 'LineWidth', 1.2, ...
                 'Color', colors(iS, :), ... 
                 'DisplayName', sprintf('Subject %d', iS));
    end
   
    plot(meanX(iS), meanY(iS), 'hexagram', 'MarkerSize', 20, ...
         'MarkerFaceColor', colors(iS, :), 'MarkerEdgeColor', 'k', ... 
         'DisplayName', 'Average Points');
end

xlabel('AS Accuracy Difference Score (Pro - Anti)');
ylabel('CR Average Trials to Error');
grid on;
ax = gca;
ax.FontSize = 20;
box on;
hold off;

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 2: TrialsToError vs SimonCongruency
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
SimonDiffScore = cell(1, numel(cfg.analysisID));
SESimonDiffScore = cell(1, numel(cfg.analysisID));
avgTrialsToError = cell(1, numel(cfg.analysisID));
SETrialsToError = cell(1, numel(cfg.analysisID));

x = cell(1, numel(cfg.analysisID));
y = cell(1, numel(cfg.analysisID));
x_err = cell(1, numel(cfg.analysisID));
y_err = cell(1, numel(cfg.analysisID));

colors = lines(numel(cfg.analysisID));

meanX = NaN(1, numel(cfg.analysisID));
meanY = NaN(1, numel(cfg.analysisID));

for iS = 1:numel(cfg.analysisID)

    % session-level data
    nSessions = length(metrics_mt{iS});
    SimonDiffScore{iS} = NaN(1, nSessions);
    SESimonDiffScore{iS} = NaN(1, nSessions);
    avgTrialsToError{iS} = NaN(1, nSessions);
    SETrialsToError{iS} = NaN(1, nSessions);
    %temps
    congruentAcc{iS} = NaN(1, nSessions);
    incongruentAcc{iS} = NaN(1, nSessions);
    congruentRT{iS} = NaN(1, nSessions);
    incongruentRT{iS} = NaN(1, nSessions);

    SE_congruentAcc{iS} = NaN(1, nSessions);
    SE_incongruentAcc{iS} = NaN(1, nSessions);
    SE_congruentRT{iS} = NaN(1, nSessions);
    SE_incongruentRT{iS} = NaN(1, nSessions);

% {'left-left', 'left-right', 'right-right', 'right-left'}

    for i = 1:nSessions
        % Extract AS simon effect difference scores by session
        congruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(1,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,1)) / 2;
        incongruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(2,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,1)) / 2;
        SimonDiffScore{iS}(i) = congruentAcc{iS}(i) - incongruentAcc{iS}(i);
        
        SE_congruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(1,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,3)^2) / 4);
        SE_incongruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(2,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,3)^2) / 4);
        SESimonDiffScore{iS}(i) = sqrt(SE_congruentAcc{iS}(i)^2 + SE_incongruentAcc{iS}(i)^2);

        % Extract CR avg trials to error by session
        avgTrialsToError{iS}(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 1);
        SETrialsToError{iS}(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 3);
    end

    valid = ~isnan(avgTrialsToError{iS}) & ~isnan(SimonDiffScore{iS});

    x{iS} = SimonDiffScore{iS}(valid); 
    y{iS} = avgTrialsToError{iS}(valid); 
    x_err{iS} = SESimonDiffScore{iS}(valid); 
    y_err{iS} = SETrialsToError{iS}(valid); 

    if ~isempty(x{iS})
        meanX(iS) = mean(x{iS});
        meanY(iS) = mean(y{iS});
    end
end

figure;
hold on;

for iS = 1:numel(cfg.analysisID)

    if ~isempty(x{iS})
        errorbar(x{iS}, y{iS}, y_err{iS}, y_err{iS}, x_err{iS}, x_err{iS}, 'o', ...
                 'MarkerSize', 8, 'MarkerEdgeColor', 'none', ... 
                 'MarkerFaceColor', colors(iS, :), 'LineWidth', 1.2, ...
                 'Color', colors(iS, :), ... 
                 'DisplayName', sprintf('Subject %d', iS));
    end
   
    plot(meanX(iS), meanY(iS), 'hexagram', 'MarkerSize', 20, ...
         'MarkerFaceColor', colors(iS, :), 'MarkerEdgeColor', 'k', ... 
         'DisplayName', 'Average Points');
end

xlabel('AS Accuracy Simon Congruence Difference Score (Cong. - Incong.)');
ylabel('CR Average Trials to Error');
grid on;
ax = gca;
ax.FontSize = 20; 
box on;
hold off;

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 3: ProMinusAnti vs SimonCongruency
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
SimonDiffScore = cell(1, numel(cfg.analysisID));
SESimonDiffScore = cell(1, numel(cfg.analysisID));
ASDiffScore = cell(1, numel(cfg.analysisID));
SEASDiffScore = cell(1, numel(cfg.analysisID));

x = cell(1, numel(cfg.analysisID));
y = cell(1, numel(cfg.analysisID));
x_err = cell(1, numel(cfg.analysisID));
y_err = cell(1, numel(cfg.analysisID));

colors = lines(numel(cfg.analysisID));

meanX = NaN(1, numel(cfg.analysisID));
meanY = NaN(1, numel(cfg.analysisID));

for iS = 1:numel(cfg.analysisID)

    % session-level data
    nSessions = length(metrics_mt{iS});
    SimonDiffScore{iS} = NaN(1, nSessions);
    SESimonDiffScore{iS} = NaN(1, nSessions);
    ASDiffScore{iS} = NaN(1, nSessions);
    SEASDiffScore{iS} = NaN(1, nSessions);
    %temps
    congruentAcc{iS} = NaN(1, nSessions);
    incongruentAcc{iS} = NaN(1, nSessions);
    congruentRT{iS} = NaN(1, nSessions);
    incongruentRT{iS} = NaN(1, nSessions);

    SE_congruentAcc{iS} = NaN(1, nSessions);
    SE_incongruentAcc{iS} = NaN(1, nSessions);
    SE_congruentRT{iS} = NaN(1, nSessions);
    SE_incongruentRT{iS} = NaN(1, nSessions);

% {'left-left', 'left-right', 'right-right', 'right-left'}

    for i = 1:nSessions
        % Extract AS simon effect difference scores by session
        congruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(1,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,1)) / 2;
        incongruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(2,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,1)) / 2;
        SimonDiffScore{iS}(i) = congruentAcc{iS}(i) - incongruentAcc{iS}(i);
        
        SE_congruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(1,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,3)^2) / 4);
        SE_incongruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(2,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,3)^2) / 4);
        SESimonDiffScore{iS}(i) = sqrt(SE_congruentAcc{iS}(i)^2 + SE_incongruentAcc{iS}(i)^2);

        % Extract AS accuracy difference scores by session
        ASDiffScore{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_ProMinusAnti(1, 1);
        SEASDiffScore{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_ProMinusAnti(1, 3);
    end

    valid = ~isnan(ASDiffScore{iS}) & ~isnan(SimonDiffScore{iS});

    x{iS} = SimonDiffScore{iS}(valid); 
    y{iS} = ASDiffScore{iS}(valid); 
    x_err{iS} = SESimonDiffScore{iS}(valid); 
    y_err{iS} = SEASDiffScore{iS}(valid); 

    if ~isempty(x{iS})
        meanX(iS) = mean(x{iS});
        meanY(iS) = mean(y{iS});
    end
end

figure;
hold on;

for iS = 1:numel(cfg.analysisID)

    if ~isempty(x{iS})
        errorbar(x{iS}, y{iS}, y_err{iS}, y_err{iS}, x_err{iS}, x_err{iS}, 'o', ...
                 'MarkerSize', 8, 'MarkerEdgeColor', 'none', ... 
                 'MarkerFaceColor', colors(iS, :), 'LineWidth', 1.2, ...
                 'Color', colors(iS, :), ... 
                 'DisplayName', sprintf('Subject %d', iS));
    end
   
    plot(meanX(iS), meanY(iS), 'hexagram', 'MarkerSize', 20, ...
         'MarkerFaceColor', colors(iS, :), 'MarkerEdgeColor', 'k', ... 
         'DisplayName', 'Average Points');
end

xlabel('AS Accuracy Simon Congruence Difference Score (Cong. - Incong.)');
ylabel('AS Accuracy Difference Score (Pro - Anti)');
grid on;
ax = gca;
ax.FontSize = 20; 
box on;
hold off;



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 4: AS Figure
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
SimonDiffScore = cell(1, numel(cfg.analysisID));
SESimonDiffScore = cell(1, numel(cfg.analysisID));
ASDiffScore = cell(1, numel(cfg.analysisID));
SEASDiffScore = cell(1, numel(cfg.analysisID));
RT_SimonDiffScore = cell(1, numel(cfg.analysisID));
RT_SESimonDiffScore = cell(1, numel(cfg.analysisID));
RT_ASDiffScore = cell(1, numel(cfg.analysisID));
RT_SEASDiffScore = cell(1, numel(cfg.analysisID));

colors = lines(numel(cfg.analysisID));

for iS = 1:numel(cfg.analysisID)

    % session-level data
    nSessions = length(metrics_mt{iS});
    SimonDiffScore{iS} = NaN(1, nSessions);
    SESimonDiffScore{iS} = NaN(1, nSessions);
    ASDiffScore{iS} = NaN(1, nSessions);
    SEASDiffScore{iS} = NaN(1, nSessions);
    RT_SimonDiffScore{iS} = NaN(1, nSessions);
    RT_SESimonDiffScore{iS} = NaN(1, nSessions);
    RT_ASDiffScore{iS} = NaN(1, nSessions);
    RT_SEASDiffScore{iS} = NaN(1, nSessions);

    congruentAcc{iS} = NaN(1, nSessions);
    incongruentAcc{iS} = NaN(1, nSessions);
    congruentRT{iS} = NaN(1, nSessions);
    incongruentRT{iS} = NaN(1, nSessions);

    SE_congruentAcc{iS} = NaN(1, nSessions);
    SE_incongruentAcc{iS} = NaN(1, nSessions);
    SE_congruentRT{iS} = NaN(1, nSessions);
    SE_incongruentRT{iS} = NaN(1, nSessions);

    proAcc{iS} = NaN(1, nSessions);
    antiAcc{iS} = NaN(1, nSessions);
    proRT{iS} = NaN(1, nSessions);
    antiRT{iS} = NaN(1, nSessions);

    SE_proAcc{iS} = NaN(1, nSessions);
    SE_antiAcc{iS} = NaN(1, nSessions);
    SE_proRT{iS} = NaN(1, nSessions);
    SE_antiRT{iS} = NaN(1, nSessions);

% {'left-left', 'left-right', 'right-right', 'right-left'}

    for i = 1:nSessions
        % Extract simon difference scores by session
        %acc
        congruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(1,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,1)) / 2;
        incongruentAcc{iS}(i) = (metrics_mt{iS}(i).Accuracy_Cong_Combined(2,1) + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,1)) / 2;
        SimonDiffScore{iS}(i) = congruentAcc{iS}(i) - incongruentAcc{iS}(i);
        
        SE_congruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(1,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(3,3)^2) / 4);
        SE_incongruentAcc{iS}(i) = sqrt((metrics_mt{iS}(i).Accuracy_Cong_Combined(2,3)^2 + metrics_mt{iS}(i).Accuracy_Cong_Combined(4,3)^2) / 4);
        SESimonDiffScore{iS}(i) = sqrt(SE_congruentAcc{iS}(i)^2 + SE_incongruentAcc{iS}(i)^2);

        %rt
        congruentRT{iS}(i) = (metrics_mt{iS}(i).RT_Cong_Combined(1,1) + metrics_mt{iS}(i).RT_Cong_Combined(3,1)) / 2;
        incongruentRT{iS}(i) = (metrics_mt{iS}(i).RT_Cong_Combined(2,1) + metrics_mt{iS}(i).RT_Cong_Combined(4,1)) / 2;
        RT_SimonDiffScore{iS}(i) = congruentRT{iS}(i) - incongruentRT{iS}(i);
        
        SE_congruentRT{iS}(i) = sqrt((metrics_mt{iS}(i).RT_Cong_Combined(1,3)^2 + metrics_mt{iS}(i).RT_Cong_Combined(3,3)^2) / 4);
        SE_incongruentRT{iS}(i) = sqrt((metrics_mt{iS}(i).RT_Cong_Combined(2,3)^2 + metrics_mt{iS}(i).RT_Cong_Combined(4,3)^2) / 4);
        RT_SESimonDiffScore{iS}(i) = sqrt(SE_congruentRT{iS}(i)^2 + SE_incongruentRT{iS}(i)^2);

        % Extract AS difference scores by session
        %acc
        proAcc{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_Pro(1,1);
        antiAcc{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_Anti(1,1);
        ASDiffScore{iS}(i) = proAcc{iS}(i) - antiAcc{iS}(i);
        
        SE_proAcc{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_Pro(1,3);
        SE_antiAcc{iS}(i) = metrics_mt{iS}(i).AccuracyMeanSE_Anti(1,3);
        SEASDiffScore{iS}(i) = sqrt(SE_proAcc{iS}(i)^2 + SE_antiAcc{iS}(i)^2);

        %rt
        proRT{iS}(i) = metrics_mt{iS}(i).RTMeanSE_Pro(1,1);
        antiRT{iS}(i) = metrics_mt{iS}(i).RTMeanSE_Anti(1,1);
        RT_ASDiffScore{iS}(i) = proRT{iS}(i) - antiRT{iS}(i);
        
        SE_proRT{iS}(i) = metrics_mt{iS}(i).RTMeanSE_Pro(1,3);
        SE_antiRT{iS}(i) = metrics_mt{iS}(i).RTMeanSE_Anti(1,3);
        RT_SEASDiffScore{iS}(i) = sqrt(SE_proRT{iS}(i)^2 + SE_antiRT{iS}(i)^2);
    end

    valid = ~isnan(ASDiffScore{iS}) & ~isnan(SimonDiffScore{iS});

    %accuracy
    congruentAcc{iS} = congruentAcc{iS}(valid);
    SE_congruentAcc{iS} = SE_congruentAcc{iS}(valid);
    incongruentAcc{iS} = incongruentAcc{iS}(valid);
    SE_incongruentAcc{iS} = SE_incongruentAcc{iS}(valid);
    SimonDiffScore{iS} = SimonDiffScore{iS}(valid);
    SESimonDiffScore{iS} = SESimonDiffScore{iS}(valid);

    proAcc{iS} = proAcc{iS}(valid);
    SE_proAcc{iS} = SE_proAcc{iS}(valid);
    antiAcc{iS} = antiAcc{iS}(valid);
    SE_antiAcc{iS} = SE_antiAcc{iS}(valid);
    ASDiffScore{iS} = ASDiffScore{iS}(valid);
    SEASDiffScore{iS} = SEASDiffScore{iS}(valid);

    %rt
    congruentRT{iS} = congruentRT{iS}(valid);
    SE_congruentRT{iS} = SE_congruentRT{iS}(valid);
    incongruentRT{iS} = incongruentRT{iS}(valid);
    SE_incongruentRT{iS} = SE_incongruentRT{iS}(valid);
    RT_SimonDiffScore{iS} = RT_SimonDiffScore{iS}(valid);
    RT_SESimonDiffScore{iS} = RT_SESimonDiffScore{iS}(valid);

    proRT{iS} = proRT{iS}(valid);
    SE_proRT{iS} = SE_proRT{iS}(valid);
    antiRT{iS} = antiRT{iS}(valid);
    SE_antiRT{iS} = SE_antiRT{iS}(valid);
    RT_ASDiffScore{iS} = RT_ASDiffScore{iS}(valid);
    RT_SEASDiffScore{iS} = RT_SEASDiffScore{iS}(valid);


    if ~isempty(SimonDiffScore{iS})
        meanCongruentAcc(iS) = mean(congruentAcc{iS});
        meanIncongruentAcc(iS) = mean(incongruentAcc{iS});
        meanProAcc(iS) = mean(proAcc{iS});
        meanAntiAcc(iS) = mean(antiAcc{iS});

        meanCongruentRT(iS) = mean(congruentRT{iS});
        meanIncongruentRT(iS) = mean(incongruentRT{iS});
        meanProRT(iS) = mean(proRT{iS});
        meanAntiRT(iS) = mean(antiRT{iS});
        
        meanSimonDiffScore(iS) = mean(SimonDiffScore{iS});
        meanASDiffScore(iS) = mean(ASDiffScore{iS});
        RT_meanSimonDiffScore(iS) = mean(RT_SimonDiffScore{iS});
        RT_meanASDiffScore(iS) = mean(RT_ASDiffScore{iS});

    % error bars
    subj_SE_congruentAcc(iS) = sqrt(sum(SE_congruentAcc{iS} .^ 2)) / nSessions;
    subj_SE_incongruentAcc(iS) = sqrt(sum(SE_incongruentAcc{iS} .^ 2)) / nSessions;
    subj_SE_SimonDiffAcc(iS) = sqrt(subj_SE_congruentAcc(iS)^2 + subj_SE_incongruentAcc(iS)^2);
    subj_SE_congruentRT(iS) = sqrt(sum(SE_congruentRT{iS} .^ 2)) / nSessions;
    subj_SE_incongruentRT(iS) = sqrt(sum(SE_incongruentRT{iS} .^ 2)) / nSessions;
    subj_SE_SimonDiffRT(iS) = sqrt(subj_SE_congruentRT(iS)^2 + subj_SE_incongruentRT(iS)^2);

    subj_SE_proAcc(iS) = sqrt(sum(SE_proAcc{iS} .^ 2)) / nSessions;
    subj_SE_antiAcc(iS) = sqrt(sum(SE_antiAcc{iS} .^ 2)) / nSessions;
    subj_SE_ASDiffAcc(iS) = sqrt(subj_SE_proAcc(iS)^2 + subj_SE_antiAcc(iS)^2);
    subj_SE_proRT(iS) = sqrt(sum(SE_proRT{iS} .^ 2)) / nSessions;
    subj_SE_antiRT(iS) = sqrt(sum(SE_antiRT{iS} .^ 2)) / nSessions;
    subj_SE_ASDiffRT(iS) = sqrt(subj_SE_proRT(iS)^2 + subj_SE_antiRT(iS)^2);
    end

end
numSubjects = numel(cfg.analysisID);

figure;
sgtitle('Figure 1', 'FontSize', 22, 'HorizontalAlignment', 'left', 'FontWeight', 'bold', 'FontName', 'Helvetica Neue');

% --- PANEL 1: MONKEY-WISE AS AND PS ACCURACY
subplot(4, 3, 1);
hold on;

xPro = 1;  % 'Pro' at position 1
xAnti = 2; % 'Anti' at position 2
xStar = 0.9; % Position to the right of "Anti" for the star

meanPro = mean(meanProAcc);
meanAnti = mean(meanAntiAcc);
meanErrPro = sqrt(sum(subj_SE_proAcc.^2) / numSubjects);
meanErrAnti = sqrt(sum(subj_SE_antiAcc.^2) / numSubjects);

% Plot individual lines for each subject
for iS = 1:numSubjects
    yPro = meanProAcc(iS);
    yAnti = meanAntiAcc(iS);
    errPro = subj_SE_proAcc(iS);  
    errAnti = subj_SE_antiAcc(iS); 
    
    plot([xPro, xAnti], [yPro, yAnti], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yPro + errPro < yAnti - errAnti) || (yPro - errPro > yAnti + errAnti)
        % Plot a star if error bars do not overlap
        plot(xStar, yPro, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot the average line
plot([xPro, xAnti], [meanPro, meanAnti], '-', 'Color', 'k', ...
    'LineWidth', 2);

if (meanPro + meanErrPro < meanAnti - meanErrAnti) || ...
   (meanPro - meanErrPro > meanAnti + meanErrAnti)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanPro, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xPro, xAnti]);
xticklabels({'Pro', 'Anti'});
ylabel('Acc.');
xlabel('Saccade Type');
title('A', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
axis padded;

hold off;


% --- PANEL 2: MONKEY-WISE AS AND PS ACCURACY DIFF SCORES
subplot(4, 3, 2);
hold on;

subjectIDs = cfg.analysisID;
firstLetters = arrayfun(@(id) id{1}(1), subjectIDs, 'UniformOutput', false);

barHandles = bar(meanASDiffScore, 'FaceColor', 'flat', 'EdgeColor', 'none'); 

for iS = 1:numSubjects
    barHandles.CData(iS, :) = colors(iS, :);
end

x = 1:numSubjects; % x positions of the bars
errorbar(x, meanASDiffScore, subj_SE_ASDiffAcc, 'k.', 'LineWidth', 1.5);

xticks(1:numSubjects);
xticklabels(firstLetters);
ylabel('Pro - Anti Acc.');
xlabel('Subject');
ylim([-0.18, 0.1]);
title('B', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
%grid on;
%axis padded;

hold off;

% --- PANEL 3: MONKEY-WISE DIFFERENCE SCORES SHOWING EACH SESSION
subplot(4, 3, 3);
hold on;

averageASDiffScore = zeros(1, max(cellfun(@numel, ASDiffScore))); 
SE_ASDiffScore = zeros(1, max(cellfun(@numel, ASDiffScore))); 

for iS = 1:numSubjects
    sessionNumbers = 1:numel(ASDiffScore{iS}); 
    yData = ASDiffScore{iS}; % Pro - Anti accuracy for each session
    
    plot(sessionNumbers, yData, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    
    averageASDiffScore(1:numel(yData)) = averageASDiffScore(1:numel(yData)) + yData;
    
    SE_ASDiffScore(1:numel(yData)) = SE_ASDiffScore(1:numel(yData)) + (yData - mean(yData)).^2;
end

yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

averageASDiffScore = averageASDiffScore / numSubjects;

SE_ASDiffScore = sqrt(SE_ASDiffScore / (numSubjects * (numSubjects - 1)));

% Plot grey cloud around the average line
xSessions = 1:numel(averageASDiffScore);
fill([xSessions, fliplr(xSessions)], ...
    [averageASDiffScore - SE_ASDiffScore, fliplr(averageASDiffScore + SE_ASDiffScore)], ...
    [0.4, 0.4, 0.4], 'EdgeColor', 'none', 'FaceAlpha', 0.3);

% Plot average line in black
plot(xSessions, averageASDiffScore, 'k-', 'LineWidth', 2);

xlabel('Session');
ylabel('Pro - Anti Acc.');
title('C', 'FontSize', 18);
ylim([-0.4, 0.3]);
set(gca, 'TickLength', [0 0]);
%axis padded;

hold off;


% --- PANEL 4: MONKEY-WISE AS AND PS RT
subplot(4, 3, 4);
hold on;

xPro = 1;  % 'Pro' at position 1
xAnti = 2; % 'Anti' at position 2
xStar = 0.9; % Position to the right of "Anti" for the star

meanPro = mean(meanProRT);
meanAnti = mean(meanAntiRT);
meanErrPro = sqrt(sum(subj_SE_proRT.^2) / numSubjects);
meanErrAnti = sqrt(sum(subj_SE_antiRT.^2) / numSubjects);

for iS = 1:numSubjects
    yPro = meanProRT(iS);  
    yAnti = meanAntiRT(iS); 
    errPro = subj_SE_proRT(iS);  
    errAnti = subj_SE_antiRT(iS); 
    
    % Plot points and connecting line
    plot([xPro, xAnti], [yPro, yAnti], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yPro + errPro < yAnti - errAnti) || (yPro - errPro > yAnti + errAnti)
        % Plot a star if error bars do not overlap
        plot(xStar, yPro, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot average line
plot([xPro, xAnti], [meanPro, meanAnti], '-', 'Color', 'k', ...
    'LineWidth', 2);

if (meanPro + meanErrPro < meanAnti - meanErrAnti) || ...
   (meanPro - meanErrPro > meanAnti + meanErrAnti)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanPro, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xPro, xAnti]);
xticklabels({'Pro', 'Anti'});
ylabel('RT');
xlabel('Saccade Type');
title('D', 'FontSize', 18);
axis padded;
set(gca, 'TickLength', [0 0]);

hold off;


% --- PANEL 5: MONKEY-WISE AS AND PS RT DIFF SCORES
subplot(4, 3, 5);
hold on;

subjectIDs = cfg.analysisID;
firstLetters = arrayfun(@(id) id{1}(1), subjectIDs, 'UniformOutput', false);

barHandles = bar(RT_meanASDiffScore, 'FaceColor', 'flat', 'EdgeColor', 'none'); % Set FaceColor to 'flat' for individual coloring

for iS = 1:numSubjects
    barHandles.CData(iS, :) = colors(iS, :); 
end

x = 1:numSubjects; % x positions of the bars
errorbar(x, RT_meanASDiffScore, subj_SE_ASDiffRT, 'k.', 'LineWidth', 1.5);

xticks(1:numSubjects);
xticklabels(firstLetters);
ylabel('Pro - Anti RT');
xlabel('Subject');
ylim([-0.18, 0.1]);
title('E', 'FontSize', 18);
%grid on;
%axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 6: MONKEY-WISE RT DIFFERENCE SCORES SHOWING EACH SESSION
subplot(4, 3, 6);
hold on;

averageRTDiffScore = zeros(1, max(cellfun(@numel, RT_ASDiffScore))); 
SE_RTDiffScore = zeros(1, max(cellfun(@numel, RT_ASDiffScore))); 

for iS = 1:numSubjects
    sessionNumbers = 1:numel(RT_ASDiffScore{iS});
    yData = RT_ASDiffScore{iS}; % Pro - Anti RT for each session
    
    % Plot line connecting the points
    plot(sessionNumbers, yData, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    
    averageRTDiffScore(1:numel(yData)) = averageRTDiffScore(1:numel(yData)) + yData;
    
    SE_RTDiffScore(1:numel(yData)) = SE_RTDiffScore(1:numel(yData)) + (yData - mean(yData)).^2;
end

yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

averageRTDiffScore = averageRTDiffScore / numSubjects;
SE_RTDiffScore = sqrt(SE_RTDiffScore / (numSubjects * (numSubjects - 1)));

% Plot the grey cloud around the average line
xSessions = 1:numel(averageRTDiffScore);
fill([xSessions, fliplr(xSessions)], ...
    [averageRTDiffScore - SE_RTDiffScore, fliplr(averageRTDiffScore + SE_RTDiffScore)], ...
    [0.4, 0.4, 0.4], 'EdgeColor', 'none', 'FaceAlpha', 0.4); 

% Plot the average line in black
plot(xSessions, averageRTDiffScore, 'k-', 'LineWidth', 2);

xlabel('Session');
ylabel('Pro - Anti RT');
title('F', 'FontSize', 18);
ylim([-0.4, 0.3]);
%axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 7: MONKEY-WISE SIMON CONGRUENT AND INCONGRUENT ACCURACY
subplot(4, 3, 7);
hold on;

xCong = 1;  % 'Congruent' at position 1
xIncong = 2; % 'Incongruent' at position 2
xStar = 0.9; % Position to the right of "Incongruent" for the star

meanCong = mean(meanCongruentAcc);
meanIncong = mean(meanIncongruentAcc);
meanErrCong = sqrt(sum(subj_SE_congruentAcc.^2) / numSubjects);
meanErrIncong = sqrt(sum(subj_SE_incongruentAcc.^2) / numSubjects);

for iS = 1:numSubjects
    yCong = meanCongruentAcc(iS);  
    yIncong = meanIncongruentAcc(iS); 
    errCong = subj_SE_congruentAcc(iS);  
    errIncong = subj_SE_incongruentAcc(iS); 
    
    % Plot points and connecting line
    plot([xCong, xIncong], [yCong, yIncong], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yCong + errCong < yIncong - errIncong) || (yCong - errCong > yIncong + errIncong)
        % Plot a star if error bars do not overlap
        plot(xStar, yCong, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

plot([xCong, xIncong], [meanCong, meanIncong], '-', 'Color', 'k', ...
    'LineWidth', 2);

if (meanCong + meanErrCong < meanIncong - meanErrIncong) || ...
   (meanCong - meanErrCong > meanIncong + meanErrIncong)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanCong, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xCong, xIncong]);
xticklabels({'Congruent', 'Incongruent'});
ylabel('Acc.');
xlabel('Simon Congruence');
title('G', 'FontSize', 18);
axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 8: MONKEY-WISE CONGRUENT AND INCONGRUENT ACCURACY DIFF SCORES
subplot(4, 3, 8);
hold on;

subjectIDs = cfg.analysisID;
firstLetters = arrayfun(@(id) id{1}(1), subjectIDs, 'UniformOutput', false);

% Create the bar plot
barHandles2 = bar(meanSimonDiffScore, 'FaceColor', 'flat', 'EdgeColor', 'none'); 

% Apply colors to the bars
for iS = 1:numSubjects
    barHandles2.CData(iS, :) = colors(iS, :); 
end

x = 1:numSubjects; 
errorbar(x, meanSimonDiffScore, subj_SE_SimonDiffAcc, 'k.', 'LineWidth', 1.5);

xticks(1:numSubjects);
xticklabels(firstLetters);
ylabel('Cong. - Incong. Acc.');
xlabel('Subject');
ylim([-0.18, 0.1]);
title('H', 'FontSize', 18);
%grid on;
%axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 9: MONKEY-WISE SIMON DIFFERENCE SCORES SHOWING EACH SESSION
subplot(4, 3, 9);
hold on;

averageSimonDiffScore = zeros(1, max(cellfun(@numel, SimonDiffScore))); 
SE_SimonDiffScore = zeros(1, max(cellfun(@numel, SimonDiffScore)));

for iS = 1:numSubjects
    sessionNumbers2 = 1:numel(SimonDiffScore{iS}); 
    yData2 = SimonDiffScore{iS}; 
    
    % Plot line connecting the points
    plot(sessionNumbers2, yData2, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    
    averageSimonDiffScore(1:numel(yData2)) = averageSimonDiffScore(1:numel(yData2)) + yData2;
    SE_SimonDiffScore(1:numel(yData2)) = SE_SimonDiffScore(1:numel(yData2)) + (yData2 - mean(yData2)).^2;
end

% Grey horizontal line at y = 0
yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

averageSimonDiffScore = averageSimonDiffScore / numSubjects;
SE_SimonDiffScore = sqrt(SE_SimonDiffScore / (numSubjects * (numSubjects - 1)));

% Plot the grey cloud around the average line
xSessions = 1:numel(averageSimonDiffScore);
fill([xSessions, fliplr(xSessions)], ...
    [averageSimonDiffScore - SE_SimonDiffScore, fliplr(averageSimonDiffScore + SE_SimonDiffScore)], ...
    [0.4, 0.4, 0.4], 'EdgeColor', 'none', 'FaceAlpha', 0.4);

plot(xSessions, averageSimonDiffScore, 'k-', 'LineWidth', 2);

xlabel('Session');
ylabel('Cong. - Incong. Acc.');
title('I', 'FontSize', 18);
ylim([-0.4, 0.3]);
%axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 10: MONKEY-WISE CONGRUENT AND INCONGRUENT RT
subplot(4, 3, 10);
hold on;

xCong = 1;  % 'Congruent' at position 1
xIncong = 2; % 'Incongruent' at position 2
xStar = 0.9; % Position to the right of "Incongruent" for the star

meanCong = mean(meanCongruentRT);
meanIncong = mean(meanIncongruentRT);
meanErrCong = sqrt(sum(subj_SE_congruentRT.^2) / numSubjects);
meanErrIncong = sqrt(sum(subj_SE_incongruentRT.^2) / numSubjects);

% Plot individual lines for each subject
for iS = 1:numSubjects
    yCong = meanCongruentRT(iS); 
    yIncong = meanIncongruentRT(iS); 
    errCong = subj_SE_congruentRT(iS);  
    errIncong = subj_SE_incongruentRT(iS); 
    
    % Plot points and connecting line
    plot([xCong, xIncong], [yCong, yIncong], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yCong + errCong < yIncong - errIncong) || (yCong - errCong > yIncong + errIncong)
        % Plot a star if error bars do not overlap
        plot(xStar, yCong, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot the average line
plot([xCong, xIncong], [meanCong, meanIncong], '-', 'Color', 'k', ...
    'LineWidth', 2);

if (meanCong + meanErrCong < meanIncong - meanErrIncong) || ...
   (meanCong - meanErrCong > meanIncong + meanErrIncong)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanCong, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xCong, xIncong]);
xticklabels({'Congruent', 'Incongruent'});
ylabel('RT');
xlabel('Simon Congruence');
title('J', 'FontSize', 18);
axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 11: MONKEY-WISE AS AND PS RT DIFF SCORES
subplot(4, 3, 11);
hold on;

subjectIDs = cfg.analysisID;
firstLetters = arrayfun(@(id) id{1}(1), subjectIDs, 'UniformOutput', false);

barHandles2 = bar(RT_meanSimonDiffScore, 'FaceColor', 'flat', 'EdgeColor', 'none'); 
for iS = 1:numSubjects
    barHandles2.CData(iS, :) = colors(iS, :); 
end

x = 1:numSubjects; % x positions of the bars
errorbar(x, RT_meanSimonDiffScore, subj_SE_SimonDiffRT, 'k.', 'LineWidth', 1.5);

xticks(1:numSubjects);
xticklabels(firstLetters);
ylabel('Cong. - Incong. RT');
xlabel('Subject');
ylim([-0.18, 0.1]);
title('K', 'FontSize', 18);
%grid on;
%axis padded;
set(gca, 'TickLength', [0 0]);

hold off;

% --- PANEL 12: MONKEY-WISE RT DIFFERENCE SCORES SHOWING EACH SESSION
subplot(4, 3, 10);
hold on;

averageRTSimonDiffScore = zeros(1, max(cellfun(@numel, RT_SimonDiffScore))); 
SE_RTSimonDiffScore = zeros(1, max(cellfun(@numel, RT_SimonDiffScore))); 

for iS = 1:numSubjects
    sessionNumbers2 = 1:numel(RT_SimonDiffScore{iS});
    yData2 = RT_SimonDiffScore{iS};
    
    % Plot line connecting the points
    plot(sessionNumbers2, yData2, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    
    averageRTSimonDiffScore(1:numel(yData2)) = averageRTSimonDiffScore(1:numel(yData2)) + yData2;
    SE_RTSimonDiffScore(1:numel(yData2)) = SE_RTSimonDiffScore(1:numel(yData2)) + (yData2 - mean(yData2)).^2;
end

% Grey horizontal line at y = 0
yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

averageRTSimonDiffScore = averageRTSimonDiffScore / numSubjects;
SE_RTSimonDiffScore = sqrt(SE_RTSimonDiffScore / (numSubjects * (numSubjects - 1)));

% Plot the grey cloud around the average line
xSessions = 1:numel(averageRTSimonDiffScore);
fill([xSessions, fliplr(xSessions)], ...
    [averageRTSimonDiffScore - SE_RTSimonDiffScore, fliplr(averageRTSimonDiffScore + SE_RTSimonDiffScore)], ...
    [0.4, 0.4, 0.4], 'EdgeColor', 'none', 'FaceAlpha', 0.4); 

% Plot average line in black
plot(xSessions, averageRTSimonDiffScore, 'k-', 'LineWidth', 2);

xlabel('Session');
ylabel('Cong. - Incong. RT');
title('L', 'FontSize', 18);
ylim([-0.4, 0.3]);
set(gca, 'TickLength', [0 0]);
%axis padded;

hold off;


% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 5: CR Figure
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

colors = lines(numel(cfg.analysisID));

figure;
sgtitle('Figure 2', 'FontSize', 22, 'HorizontalAlignment', 'left', 'FontWeight', 'bold', 'FontName', 'Helvetica Neue');

% --- PANEL 1: Trialwise accuracy for all subjects ---
nSubjects = numel(cfg.analysisID);
nStim = length(iConditions_StimInTrial); % Number of stimulus conditions
meanAccuracyAllSubjects = NaN(nSubjects, nStim);

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    accuracyNStim = NaN(nStim, nSessions); % Initialize accuracy array
    
    for i = 1:nSessions
        for stim = 1:nStim
            accuracyNStim(stim, i) = metrics_mt{iS}(i).Acc_NumStim(stim, 1);
        end
    end
    
    % Calculate mean accuracy for each stimulus condition (ignoring NaNs)
    meanAccuracyAllSubjects(iS, :) = nanmean(accuracyNStim, 2);
end

subplot(4, 3, 1);
hold on;

for iS = 1:nSubjects
    plot(1:nStim, meanAccuracyAllSubjects(iS, :), '-', 'LineWidth', 1.5, ...
         'MarkerFaceColor', colors(iS, :), 'Color', colors(iS, :));
end

ylabel('Acc.');
xticks(0:2:nStim);
xticklabels(arrayfun(@num2str, 0:2:nStim, 'UniformOutput', false));
xlabel('Stim in Trial');
ylim([-0.1 1.1]);
set(gca, 'TickLength', [0 0]);
title('A', 'FontSize', 18);
grid off;

hold off;



% --- PANEL 2: Bar graph for 75% trial
avgTrialAt75 = NaN(1, numel(cfg.analysisID));
stdTrialAt75 = NaN(1, numel(cfg.analysisID));

maxSessions = max(cellfun(@numel, metrics_mt));

for iS = 1:numel(cfg.analysisID)
    nSessions = length(metrics_mt{iS});
    TrialAt75{iS} = NaN(1, nSessions);

    for i = 1:nSessions
        accuracy = metrics_mt{iS}(i).Acc_NumStim(:, 1);
        numStim = (1:size(metrics_mt{iS}(i).Acc_NumStim, 1))';
        
        validIdx = ~isnan(accuracy);
        accuracy = accuracy(validIdx);
        numStim = numStim(validIdx);  % Keep only valid numStim corresponding to valid accuracy values
        
        % Slightly adjust the accuracy values to ensure uniqueness
        epsilon = 1e-6;  % Small value to add
        accuracy = accuracy + (rand(size(accuracy)) * epsilon);  % Add random small noise
        
        % Perform interpolation using 'pchip' method
        if ~isempty(accuracy) && ~isempty(numStim)
            TrialAt75{iS}(i) = interp1(accuracy, numStim, 0.75, 'pchip', 'extrap'); % tested using nearest to ensure validity
        end
    end

    avgTrialAt75(iS) = nanmean(TrialAt75{iS});
    stdTrialAt75(iS) = nanstd(TrialAt75{iS}) / sqrt(sum(~isnan(TrialAt75{iS}))); 
end
subplot(4,3,2);
hold on;

bar(1:numel(cfg.analysisID), avgTrialAt75, 'FaceColor', 'flat', 'CData', colors, 'EdgeColor', 'none');

errorbar(1:numel(cfg.analysisID), avgTrialAt75, stdTrialAt75, 'k.', 'LineWidth', 1);

xticks(1:numel(cfg.analysisID)); 
xticks(1:maxSessions);
xticklabels(arrayfun(@(iS) cfg.analysisID{iS}(1), 1:numel(cfg.analysisID), 'UniformOutput', false));
set(gca, 'TickLength', [0 0]);
xlabel('Subjects');
ylabel('Avg. Trial at 75% Acc.');
title('B', 'FontSize', 18);

hold off;

% --- PANEL 3: average trial number at 75% accuracy, session-wise
subplot(4,3,3)
hold on;

maxSessions = max(cellfun(@numel, metrics_mt)); 
allTrials = NaN(numel(cfg.analysisID), maxSessions);

for iS = 1:numel(cfg.analysisID)
    nSessions = length(metrics_mt{iS});
    TrialAt75{iS} = NaN(1, nSessions);

    for i = 1:nSessions
        accuracy = metrics_mt{iS}(i).Acc_NumStim(:, 1);
        numStim = (1:size(metrics_mt{iS}(i).Acc_NumStim, 1))';
        
        validIdx = ~isnan(accuracy);
        accuracy = accuracy(validIdx);
        numStim = numStim(validIdx);  
        
        % Slightly adjust the accuracy values to ensure uniqueness
        epsilon = 1e-6;  % Small value to add
        accuracy = accuracy + (rand(size(accuracy)) * epsilon);  % Add random small noise
        
        if ~isempty(accuracy) && ~isempty(numStim)
            TrialAt75{iS}(i) = interp1(accuracy, numStim, 0.75, 'pchip', 'extrap');
        end
    end

    validTrialIdx = ~isnan(TrialAt75{iS});
    sessionNumbers = 1:nSessions;
    sessionNumbers = sessionNumbers(validTrialIdx);
    validTrialAt75 = TrialAt75{iS}(validTrialIdx); 
    
    plot(sessionNumbers, validTrialAt75, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    
    allTrials(iS, sessionNumbers) = validTrialAt75;
end

meanTrialAt75 = nanmean(allTrials, 1); 
stderrTrialAt75 = nanstd(allTrials, 0, 1) ./ sqrt(sum(~isnan(allTrials), 1));

xSessions = 1:maxSessions;

plot(xSessions, meanTrialAt75, 'k-', 'LineWidth', 2, 'DisplayName', 'Mean');

% Plot the standard error shading (grey cloud)
fill([xSessions, fliplr(xSessions)], ...
     [meanTrialAt75 - stderrTrialAt75, fliplr(meanTrialAt75 + stderrTrialAt75)], ...
     [0.4, 0.4, 0.4], 'FaceAlpha', 0.3, 'EdgeColor', 'none');

xlabel('Session');
ylabel('Trial at 75% Acc.');
set(gca, 'TickLength', [0 0]);
title('C', 'FontSize', 18);
hold off;

% --- PANEL 4: Trials to error bar graph
avgTrialsToErrorPerSubject = NaN(1, numel(cfg.analysisID));
SETrialsToErrorPerSubject = NaN(1, numel(cfg.analysisID));

for iS = 1:numel(cfg.analysisID)
    nSessions = length(metrics_mt{iS});
    trialsToError = NaN(1, nSessions);
    
    for i = 1:nSessions
        trialsToError(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 1);
    end

    validTrials = trialsToError(~isnan(trialsToError));
    
    avgTrialsToErrorPerSubject(iS) = mean(validTrials);
    SETrialsToErrorPerSubject(iS) = std(validTrials) / sqrt(numel(validTrials));
end

subplot(4,3,4);
b = bar(avgTrialsToErrorPerSubject);
hold on;

b.FaceColor = 'flat';
b.CData = lines(numel(cfg.analysisID));
b.EdgeColor = 'none';

errorbar(1:numel(cfg.analysisID), avgTrialsToErrorPerSubject, SETrialsToErrorPerSubject, ...
    'k', 'LineStyle', 'none', 'LineWidth', 1.5);

xlabel('Subject');
ylabel('Avg. Trials to Error');
xticks(1:numel(cfg.analysisID));
xticklabels(arrayfun(@(iS) cfg.analysisID{iS}(1), 1:numel(cfg.analysisID), 'UniformOutput', false));
set(gca, 'TickLength', [0 0], 'Box', 'off');
title('D', 'FontSize', 18);
hold off;

% --- PANEL 5: Session-wise trials to error
subplot(4,3,5);
hold on;

maxSessions = max(cellfun(@(x) length(x), metrics_mt)); 
allTrialsToError = NaN(numel(cfg.analysisID), maxSessions);

for iS = 1:numel(cfg.analysisID)
    nSessions = length(metrics_mt{iS}); 
    avgTrialsToError = NaN(1, nSessions);
    
    for i = 1:nSessions
        avgTrialsToError(i) = metrics_mt{iS}(i).AvgTrialsToError(1, 1);
    end

    valid = ~isnan(avgTrialsToError); 
    sessionNumbers = 1:nSessions;    

    allTrialsToError(iS, sessionNumbers(valid)) = avgTrialsToError(valid);

    plot(sessionNumbers(valid), avgTrialsToError(valid), '-', ...
        'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5, ...
        'DisplayName', sprintf('Subject %d', iS));
end

meanTrialsToError = nanmean(allTrialsToError, 1); 
SETrialsToError = nanstd(allTrialsToError, 0, 1) ./ sqrt(sum(~isnan(allTrialsToError), 1)); 

xSessions = 1:maxSessions;

% Plot the mean line (black)
plot(xSessions, meanTrialsToError, 'k-', 'LineWidth', 2, 'DisplayName', 'Average');

% Plot the standard error shading (gray cloud)
fill([xSessions, fliplr(xSessions)], ...
     [meanTrialsToError - SETrialsToError, fliplr(meanTrialsToError + SETrialsToError)], ...
     [0.4, 0.4, 0.4], 'FaceAlpha', 0.3, 'EdgeColor', 'none');

xlabel('Session');
ylabel('Avg. Trials to Error');
set(gca, 'TickLength', [0 0]);
title('E', 'FontSize', 18);
hold off;


% --- PANEL 6: Trialwise RT for all subjects 
nSubjects = numel(cfg.analysisID);
nStim = length(iConditions_StimInTrial); % Number of stimulus conditions
meanAccuracyAllSubjects = NaN(nSubjects, nStim);

% Loop through each subject
for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    RTNStim = NaN(nStim, nSessions); 
    
    for i = 1:nSessions
        for stim = 1:nStim
            RTNStim(stim, i) = metrics_mt{iS}(i).RT_NumStim(stim, 1);
        end
    end
    
    meanRTAllSubjects(iS, :) = nanmean(RTNStim, 2);
end

subplot(4, 3, 7);
hold on;

for iS = 1:nSubjects
    plot(1:nStim, meanRTAllSubjects(iS, :), '-', 'LineWidth', 1.5, ...
         'MarkerFaceColor', colors(iS, :), 'Color', colors(iS, :));
end

ylabel('RT');
xticks(0:2:nStim);
xticklabels(arrayfun(@num2str, 0:2:nStim, 'UniformOutput', false));
xlabel('Stim in Trial');
axis padded;
set(gca, 'TickLength', [0 0]);
grid off;
title('F', 'FontSize', 18);

hold off;

% --- PANEL 7: RT slopes with SE error bars 

slopes = NaN(1, nSubjects);
SE_slopes = NaN(1, nSubjects);

for iS = 1:nSubjects
    x = 1:nStim;
    y = meanRTAllSubjects(iS, :);
    xValid = x(~isnan(y));
    yValid = y(~isnan(y));
    
    if numel(xValid) > 1 % Ensure there are enough points for regression
        p = polyfit(xValid, yValid, 1); % p(1) is the slope
        slopes(iS) = p(1);
        
        % Compute residuals and standard error
        yFit = polyval(p, xValid);
        residuals = yValid - yFit;
        SE_slopes(iS) = sqrt(sum(residuals.^2) / (numel(xValid) - 2)) / sqrt(sum((xValid - mean(xValid)).^2));
    end
end

subplot(4, 3, 8);
bar(1:nSubjects, slopes, 'FaceColor', 'flat', 'CData', colors, 'EdgeColor', 'none');

hold on;
errorbar(1:nSubjects, slopes, SE_slopes, 'k.', 'LineWidth', 1.5);
hold off;

xticks(1:nSubjects);
xticklabels(arrayfun(@(iS) cfg.analysisID{iS}(1), 1:numel(cfg.analysisID), 'UniformOutput', false));
xlabel('Subject');
ylabel('Slope: RT vs. Stim In Trial');
set(gca, 'TickLength', [0 0], 'Box', 'off');
title('G', 'FontSize', 18);
axis padded;


% --- PANEL 8: RT slopes per session for each subject ---
nSubjects = numel(cfg.analysisID);
nStim = length(iConditions_StimInTrial); 

sessionSlopes = cell(1, nSubjects);

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    sessionSlopes{iS} = NaN(1, nSessions); 
    
    for i = 1:nSessions
        RTData = metrics_mt{iS}(i).RT_NumStim(:, 1);
        numStim = (1:size(metrics_mt{iS}(i).RT_NumStim, 1))';
        
        validIdx = ~isnan(RTData);
        RTData = RTData(validIdx);
        numStim = numStim(validIdx);
        
        % Calculate slope using linear regression
        if numel(numStim) > 1 % Ensure enough data points
            p = polyfit(numStim, RTData, 1); % Linear fit
            sessionSlopes{iS}(i) = p(1);
        end
    end
end

% Convert cell array to matrix for easier averaging
maxSessions = max(cellfun(@numel, sessionSlopes));
allSlopes = NaN(nSubjects, maxSessions);

for iS = 1:nSubjects
    allSlopes(iS, 1:numel(sessionSlopes{iS})) = sessionSlopes{iS};
end

meanSlopes = nanmean(allSlopes, 1);
seSlopes = nanstd(allSlopes, 0, 1) ./ sqrt(sum(~isnan(allSlopes), 1));

subplot(4, 3, 9);
hold on;

for iS = 1:nSubjects
    nSessions = numel(sessionSlopes{iS});
    plot(1:nSessions, sessionSlopes{iS}, '-', 'LineWidth', 1.5, ...
         'MarkerFaceColor', colors(iS, :), 'Color', [colors(iS, :), 0.4]);
end

% Plot average line and SE cloud
x = 1:maxSessions;
fill([x, fliplr(x)], [meanSlopes + seSlopes, fliplr(meanSlopes - seSlopes)], ...
     [0.4, 0.4, 0.4], 'FaceAlpha', 0.3, 'EdgeColor', 'none');
plot(x, meanSlopes, '-k', 'LineWidth', 2);

xlabel('Session');
ylabel('Slope: RT vs. Stim In Trial');
set(gca, 'TickLength', [0 0]);
axis padded;
grid off;
title('H', 'FontSize', 18);
hold off;

% % --- PANEL 9: nBack proportion of trials subdivided by TTE with averages
% % Number of subjects
% nSubjects = numel(metrics_mt);
% 
% % Initialize a figure
% subplot(4, 3, 10);
% hold on;
% 
% % Define colors for each subject
% colors = lines(nSubjects);
% 
% % Initialize a struct to hold data for calculating averages
% TTEData = struct();
% 
% % Loop through each subject
% for iS = 1:nSubjects
%     % Extract the datasets for the current subject
%     nDatasets = numel(metrics_mt{iS});
% 
%     % Initialize arrays to store all nBack and TTE values for the subject
%     allNBack = [];
%     allTTE = [];
% 
%     for iD = 1:nDatasets
%         % Extract nBack and TTE values
%         keys = cellfun(@(c) c{1}, metrics_mt{iS}(iD).nBack);
%         vals = cellfun(@(c) c{2}, metrics_mt{iS}(iD).nBack);
% 
%         % Filter out invalid values
%         validIndices = keys >= 0;
%         keys = keys(validIndices);
%         vals = vals(validIndices);
% 
%         % Append to the subject's data
%         allNBack = [allNBack, keys];
%         allTTE = [allTTE, vals];
%     end
% 
%     % Get unique TTE values
%     uniqueTTE = unique(allTTE);
% 
%     % Loop through each unique TTE value and plot frequencies of nBack
%     for t = 1:numel(uniqueTTE)
%         currentTTE = uniqueTTE(t);
% 
%         % Filter nBack values corresponding to the current TTE
%         nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
% 
%         % Skip if there are no nBack values for this TTE
%         if isempty(nBackAtCurrentTTE)
%             continue;
%         end
% 
%         % Calculate the unique nBack values and their frequencies
%         [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
%         counts = accumarray(idx, 1);
%         relativeFrequency = counts / numel(nBackAtCurrentTTE);
% 
%         % Normalize relative frequency to [0,1] for better visualization
%         minFreq = min(relativeFrequency);
%         maxFreq = max(relativeFrequency);
%         if maxFreq > minFreq
%             normalizedFrequency = (relativeFrequency - minFreq) / (maxFreq - minFreq);
%         else
%             normalizedFrequency = zeros(size(relativeFrequency));  % Avoid division by zero
%         end
% 
%         % Plot the relative frequency for the current TTE
%         plot(uniqueNBack, normalizedFrequency + currentTTE, '-', 'LineWidth', 2, ...
%              'Color', [colors(iS, :), 0.4]);
% 
%         % Store data for calculating the average
%         if ~isfield(TTEData, sprintf('TTE_%d', currentTTE))
%             TTEData.(sprintf('TTE_%d', currentTTE)) = [];
%         end
% 
%         % Ensure both uniqueNBack and relativeFrequency are column vectors
%         uniqueNBack = uniqueNBack(:); 
%         normalizedFrequency = normalizedFrequency(:);
% 
%         % Add current subject's frequency data
%         TTEData.(sprintf('TTE_%d', currentTTE)) = ...
%             [TTEData.(sprintf('TTE_%d', currentTTE)); uniqueNBack, normalizedFrequency];
%     end
% end
% 
% % Initialize arrays to store peak positions
% peakTTEs = [];
% peakXValues = [];
% 
% % Plot the black average line and grey SEM cloud for each TTE bucket
% fieldNames = fieldnames(TTEData);
% for f = 1:numel(fieldNames)
%     currentTTE = str2double(extractAfter(fieldNames{f}, 'TTE_'));
%     data = TTEData.(fieldNames{f});
% 
%     % Extract unique nBack values and calculate average and SEM
%     if ~isempty(data)
%         uniqueNBack = unique(data(:, 1));
%         avgFrequencies = arrayfun(@(n) mean(data(data(:, 1) == n, 2)), uniqueNBack);
%         semFrequencies = arrayfun(@(n) std(data(data(:, 1) == n, 2)) / sqrt(sum(data(:, 1) == n)), uniqueNBack);
% 
%         % Plot the average line
%         plot(uniqueNBack, avgFrequencies + currentTTE, 'k-', 'LineWidth', 1.5);
% 
%         % Add grey cloud for SEM
%         upperBound = avgFrequencies + semFrequencies;
%         lowerBound = avgFrequencies - semFrequencies;
%         fill([uniqueNBack; flipud(uniqueNBack)], ...
%              [upperBound + currentTTE; flipud(lowerBound + currentTTE)], ...
%              [0.6, 0.6, 0.6], 'FaceAlpha', 0.3, 'EdgeColor', 'none');
% 
%         % Calculate the median of the x values (nBack)
%         peakXValue = median(uniqueNBack);
% 
% 
%         % Store the peak position
%         peakTTEs = [peakTTEs, currentTTE];
%         peakXValues = [peakXValues, peakXValue];
%     end
% end
% 
% % Plot the line connecting the peaks
% plot(peakXValues, peakTTEs, '-', 'LineWidth', 2, 'Color', [0.6,0.6,0.6] ...
%     , 'DisplayName', 'Peak Line');
% 
% % Add labels, title, and adjust grid
% xlabel('nBack');
% ylabel('Norm. Freq. Split by TTE');
% title('I', 'FontSize', 18);
% set(gca, 'TickLength', [0 0]);
% grid off;
% hold off;


% --- PANEL 10: nBack slopes

subplot(4,3,10); 
hold on;

for iS = 1:nSubjects
    subjectData = metrics_mt{iS};
    allNBack = [];
    allTTE = [];

    for iD = 1:numel(subjectData)
        keys = cellfun(@(c) c{1}, subjectData(iD).nBack);
        vals = cellfun(@(c) c{2}, subjectData(iD).nBack);
        
        validIndices = keys >= 0;
        keys = keys(validIndices);
        vals = vals(validIndices);
        
        allNBack = [allNBack, keys];
        allTTE = [allTTE, vals];
    end

    uniqueTTE = unique(allTTE);
    nTTE = numel(uniqueTTE);
    
    slopes = nan(nTTE, 1);

    for t = 1:nTTE
        currentTTE = uniqueTTE(t);
        
        nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
        
        % Ensure we have at least 2 unique points to fit a line
        uniqueNBack = unique(nBackAtCurrentTTE);
        if numel(uniqueNBack) < 2
            slopes(t) = NaN; % Skip this TTE (no valid slope)
            continue;
        end
        
        % Compute non-normalized frequency
        [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
        counts = accumarray(idx, 1);
        
        % Compute slope (linear fit)
        p = polyfit(uniqueNBack, counts, 1); % (linear regression)
        slopes(t) = p(1); 
    end

    uniqueTTE = uniqueTTE(:); 
    slopes = slopes(:);       
    validIndices = ~isnan(slopes);
    uniqueTTE = uniqueTTE(validIndices);  % This will be a column vector of valid TTE values
    slopes = slopes(validIndices);     

    plot(uniqueTTE, slopes, '-', 'Color', colors(iS, :), 'LineWidth', 1.5, 'MarkerFaceColor', colors(iS, :));
end

xlabel('TTE');
ylabel('Slope (freq./nBack)');
set(gca, 'YScale', 'log')
title('I', 'FontSize', 18);
yticks([10^-3, 10^-2, 10^-1, 10^0, 10^1, 10^2, 10^3]);  
yticklabels({'10^{-3}', '10^{-2}', '10^{-1}', '10^{0}', '10^{1}', '10^{2}', '10^{3}'});
axis padded;
grid off;
hold off;

% % --- PANEL 11: nBack slopes (with error bars)
% subplot(4,3,11); 
% hold on;
% 
% % Initialize an array to store the slope of each subject's fit
% subjectSlopes = nan(nSubjects, 1);
% subjectSlopesSEM = nan(nSubjects, 1);  % Initialize an array for SEM
% 
% % Loop through subjects
% for iS = 1:nSubjects
%     subjectData = metrics_mt{iS};
%     allNBack = [];
%     allTTE = [];
% 
%     for iD = 1:numel(subjectData)
%         % Extract nBack and TTE values
%         keys = cellfun(@(c) c{1}, subjectData(iD).nBack);
%         vals = cellfun(@(c) c{2}, subjectData(iD).nBack);
% 
%         % Filter out invalid values
%         validIndices = keys >= 0;
%         keys = keys(validIndices);
%         vals = vals(validIndices);
% 
%         % Append data
%         allNBack = [allNBack, keys];
%         allTTE = [allTTE, vals];
%     end
% 
%     % Get unique TTE values
%     uniqueTTE = unique(allTTE);
%     nTTE = numel(uniqueTTE);
% 
%     % Store slopes for plotting
%     slopes = nan(nTTE, 1);
% 
%     % Compute slope for each TTE
%     for t = 1:nTTE
%         currentTTE = uniqueTTE(t);
% 
%         % Filter nBack values corresponding to the current TTE
%         nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
% 
%         % Ensure we have at least 2 unique points to fit a line
%         uniqueNBack = unique(nBackAtCurrentTTE);
%         if numel(uniqueNBack) < 2
%             slopes(t) = NaN; % Skip this TTE (no valid slope)
%             continue;
%         end
% 
%         % Compute non-normalized frequency
%         [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
%         counts = accumarray(idx, 1);
% 
%         % Compute slope (linear fit)
%         p = polyfit(uniqueNBack, counts, 1); % Fit a first-degree polynomial (linear regression)
%         slopes(t) = p(1); % Extract the slope
%     end
% 
%     % Ensure uniqueTTE and slopes are column vectors
%     uniqueTTE = uniqueTTE(:);
%     slopes = slopes(:);
% 
%     % Remove NaN values
%     validIndices = ~isnan(slopes);
%     uniqueTTE = uniqueTTE(validIndices);
%     slopes = slopes(validIndices);
%     logslopes = log(slopes);
% 
%     % Fit a line to the valid uniqueTTE and slopes for this subject
%     if numel(uniqueTTE) > 1  % Ensure we have at least two points
%         p = polyfit(uniqueTTE, slopes, 1);  % Fit a linear model to uniqueTTE vs. slopes (no log)
%         %p = polyfit(uniqueTTE, logslopes, 1);  % Fit a linear model to uniqueTTE vs. slopes (with log)
%         subjectSlopes(iS) = p(1);  % Extract the slope of the fitted line
% 
%         % Calculate the SEM for the slopes
%         logslopesSEM = std(logslopes) / sqrt(numel(logslopes));
%         slopesSEM = std(slopes) / sqrt(numel(slopes));
% 
%         subjectSlopesSEM(iS) = slopesSEM;  % Store the SEM for this subject (no log)
%         %subjectSlopesSEM(iS) = logslopesSEM;  % Store the SEM for this subject (with log)
%     else
%         subjectSlopes(iS) = NaN;  % If not enough points, set NaN
%         subjectSlopesSEM(iS) = NaN;  % If not enough points, set NaN for SEM
%     end
% end
% 
% % Plot the slopes of the fitted lines for each subject, with error bars and colors matching each subject
% yline(0, 'k-', 'LineWidth', 0.5);
% errorbar(1:nSubjects, subjectSlopes, subjectSlopesSEM, 'o', 'MarkerSize', 5, 'MarkerFaceColor', 'auto', 'LineWidth', 1, 'Color', 'k');  % Add error bars
% scatter(1:nSubjects, subjectSlopes, 50, colors, 'filled');  % Use the colors array for coloring the dots
% xticks(1:nSubjects);
% xticklabels(arrayfun(@(iS) cfg.analysisID{iS}(1), 1:numel(cfg.analysisID), 'UniformOutput', false));
% xlabel('Subject');
% ylabel('Slope of slope');
% axis padded;
% ylim([-120, 120]);
% title('J', 'FontSize', 18);
% set(gca, 'TickLength', [0 0]);
% grid off;
% hold off;

% --- PANEL 11: nBack slopes (with shuffled distribution)
subplot(4,3,11); 
hold on;

subjectSlopes = nan(nSubjects, 1);
subjectSlopesSEM = nan(nSubjects, 2); 

for iS = 1:nSubjects
    subjectSlopesSEM(iS, :) = [NaN, NaN]; % Ensure it's a 1x2 row

    subjectData = metrics_mt{iS};
    allNBack = [];
    allTTE = [];

    for iD = 1:numel(subjectData)
        % Extract nBack and TTE values
        keys = cellfun(@(c) c{1}, subjectData(iD).nBack);
        vals = cellfun(@(c) c{2}, subjectData(iD).nBack);
        
        validIndices = keys >= 0;
        keys = keys(validIndices);
        vals = vals(validIndices);
        
        allNBack = [allNBack, keys];
        allTTE = [allTTE, vals];
    end

    uniqueTTE = unique(allTTE);
    nTTE = numel(uniqueTTE);
    
    slopes = nan(nTTE, 1);

    % Compute slope for each TTE
    for t = 1:nTTE
        currentTTE = uniqueTTE(t);
        
        nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
        
        % Ensure we have at least 2 unique points to fit a line
        uniqueNBack = unique(nBackAtCurrentTTE);
        if numel(uniqueNBack) < 2
            slopes(t) = NaN; % Skip this TTE (no valid slope)
            continue;
        end
        
        [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
        counts = accumarray(idx, 1);
        
        % Compute slope (linear fit)
        p = polyfit(uniqueNBack, counts, 1); 
        slopes(t) = p(1); % Extract the slope
    end

    uniqueTTE = uniqueTTE(:);
    slopes = slopes(:);
    
    validIndices = ~isnan(slopes);
    uniqueTTE = uniqueTTE(validIndices);
    slopes = slopes(validIndices);
    logslopes = log(slopes);


    % Fit a line to the valid uniqueTTE and slopes for this subject
    if numel(uniqueTTE) > 1  % Ensure we have at least two points
        p = polyfit(uniqueTTE, slopes, 1);  % Fit a linear model to uniqueTTE vs. slopes (no log)
        %p = polyfit(uniqueTTE, logslopes, 1);  % Fit a linear model to uniqueTTE vs. slopes (with log)
        subjectSlopes(iS) = p(1);  % Extract the slope of the fitted line

        shuffledSlopes = nan(100, 1);
        for i = 1:100
            shuffledP = polyfit(uniqueTTE, slopes(randperm(numel(slopes))), 1); % Shuffle slopes and fit
            shuffledSlopes(i) = shuffledP(1); % Store only the slope (not the intercept)
        end
        lowerBound = prctile(shuffledSlopes, 5);
        upperBound = prctile(shuffledSlopes, 95);
        slopemean = mean(shuffledSlopes);
        slopestddev = std(shuffledSlopes);
        %fprintf_('Lower Bound: %.4f, Upper Bound: %.4f, Mean Slope: %.4f, Slope Std Dev: %.4f\n', lowerBound, upperBound, slopemean, slopestddev);

        subjectSlopesSEM(iS, :) = [lowerBound, upperBound]; 
    

    else
        subjectSlopes(iS) = NaN;  % If not enough points, set NaN
    end
end

upperBounds = subjectSlopesSEM(:, 2);  % Upper bounds (95th percentile)
lowerBounds = subjectSlopesSEM(:, 1);  % Lower bounds (5th percentile)
% Plot the upper bound line (thin grey line)
plot(1:nSubjects, upperBounds, 'Color', [0.6 0.6 0.6], 'LineWidth', 0.1);
% Plot the lower bound line (thin grey line)
plot(1:nSubjects, lowerBounds, 'Color', [0.6 0.6 0.6], 'LineWidth', 0.1);
fill([1:nSubjects, fliplr(1:nSubjects)], ...
     [upperBounds', fliplr(lowerBounds')], ...
     [0.6 0.6 0.6], 'FaceAlpha', 0.3, 'EdgeColor', 'none');

yline(0, 'k-', 'LineWidth', 0.5);
scatter(1:nSubjects, subjectSlopes, 25, colors, 'filled');  

% Check if each subject's slope is outside of the bounds
for iS = 1:nSubjects
    if subjectSlopes(iS) < lowerBounds(iS) || subjectSlopes(iS) > upperBounds(iS)
        plot(iS, 100, '*', 'Color', 'k', 'MarkerSize', 8);
    end
end

xticks(1:nSubjects);
xticklabels(arrayfun(@(iS) cfg.analysisID{iS}(1), 1:numel(cfg.analysisID), 'UniformOutput', false));
xlabel('Subject');
ylabel('Slope of slope');
axis padded;
ylim([-120, 120]);
title('J', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
grid off;
hold off;



% --- Supplementary Figure:  Smoothed Normalized nBack Distributions for Each Subject ---

nSubjects = numel(metrics_mt);
nCols = ceil(sqrt(nSubjects)); 
nRows = ceil(nSubjects / nCols);

figure;

for iS = 1:nSubjects
    subjectData = metrics_mt{iS};
    
    subplot(nRows, nCols, iS);
    hold on;

    allNBack = [];
    allTTE = [];

    for iD = 1:numel(subjectData)
        % Extract nBack and TTE values
        keys = cellfun(@(c) c{1}, subjectData(iD).nBack);
        vals = cellfun(@(c) c{2}, subjectData(iD).nBack);
        
        % Filter out invalid values
        validIndices = keys >= 0;
        keys = keys(validIndices);
        vals = vals(validIndices);
        
        allNBack = [allNBack, keys];
        allTTE = [allTTE, vals];
    end

    % Get unique TTE values and define color shades
    uniqueTTE = unique(allTTE);
    nTTE = numel(uniqueTTE);

    baseHue = rgb2hsv(colors(iS, :)); 
    baseHue = baseHue(1); 
    saturation = 1.0;  
    
    brightnessLevels = linspace(1, 0.01, nTTE); 

    tteColors = hsv2rgb([repmat(baseHue, nTTE, 1), repmat(saturation, nTTE, 1), brightnessLevels']);

    % Loop through each TTE and plot normalized distributions
    for t = 1:nTTE
        currentTTE = uniqueTTE(t);
        
        nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
        
        if isempty(nBackAtCurrentTTE)
            continue;
        end
        
        [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
        counts = accumarray(idx, 1);
        relativeFrequency = counts / numel(nBackAtCurrentTTE);
        
        % Apply slight smoothing (smaller window size for less smoothing)
        smoothedFrequency = smoothdata(relativeFrequency, 'movmean', 5); % 'movmean' with window size 3
        
        % Normalize to range [0,1] after smoothing
        minFreq = min(smoothedFrequency);
        maxFreq = max(smoothedFrequency);
        smoothedNormalizedFrequency = (smoothedFrequency - minFreq) / (maxFreq - minFreq);
        
        plot(uniqueNBack, smoothedFrequency, '-', 'LineWidth', 2, ...
             'Color', [tteColors(t, :) 0.5]); 
    end

    xlabel('nBack');
    ylabel('Frequency');
    ylim([-0.05, 1.05]);
    xlim([-1, 17]);
    title(cfg.analysisID{iS}(1));
    set(gca, 'ytick', [0 1]);
    set(gca, 'TickLength', [0 0]);
    grid off;
    hold off;
end

sgtitle('Figure 3', 'FontSize', 22, 'HorizontalAlignment', 'left', 'FontWeight', 'bold', 'FontName', 'Helvetica Neue');

% % --- Figure: Slope of Non-Normalized Frequency vs. TTE ---
% 
% % Initialize figure
% figure; hold on;
% 
% % Loop through subjects
% for iS = 1:nSubjects
%     % Extract subject data
%     subjectData = metrics_mt{iS};
% 
%     % Extract all nBack and TTE values for this subject
%     allNBack = [];
%     allTTE = [];
% 
%     for iD = 1:numel(subjectData)
%         % Extract nBack and TTE values
%         keys = cellfun(@(c) c{1}, subjectData(iD).nBack);
%         vals = cellfun(@(c) c{2}, subjectData(iD).nBack);
% 
%         % Filter out invalid values
%         validIndices = keys >= 0;
%         keys = keys(validIndices);
%         vals = vals(validIndices);
% 
%         % Append data
%         allNBack = [allNBack, keys];
%         allTTE = [allTTE, vals];
%     end
% 
%     % Get unique TTE values
%     uniqueTTE = unique(allTTE);
%     nTTE = numel(uniqueTTE);
% 
%     % Store slopes for plotting
%     slopes = nan(nTTE, 1);
% 
%     % Compute slope for each TTE
%     for t = 1:nTTE
%         currentTTE = uniqueTTE(t);
% 
%         % Filter nBack values corresponding to the current TTE
%         nBackAtCurrentTTE = allNBack(allTTE == currentTTE);
% 
%        % Ensure we have at least 2 unique points to fit a line
%         uniqueNBack = unique(nBackAtCurrentTTE);
%         if numel(uniqueNBack) < 2
%             slopes(t) = NaN; % Skip this TTE (no valid slope)
%             continue;
%         end
% 
%         % Compute non-normalized frequency
%         [uniqueNBack, ~, idx] = unique(nBackAtCurrentTTE);
%         counts = accumarray(idx, 1);
% 
%         % Compute slope (linear fit)
%         p = polyfit(uniqueNBack, counts, 1); % Fit a first-degree polynomial (linear regression)
%         slopes(t) = p(1); % Extract the slope
%     end
% 
%     uniqueTTE = uniqueTTE(:); % Make sure uniqueTTE is a column vector
% slopes = slopes(:);       % Make sure slopes is a column vector
% validIndices = ~isnan(slopes);
% uniqueTTE = uniqueTTE(validIndices);  % This will be a column vector of valid TTE values
% slopes = slopes(validIndices);     
% 
%     % Plot scatter and connecting line for this subject
%     plot(uniqueTTE, slopes, '-', 'Color', colors(iS, :), 'LineWidth', 2, 'MarkerFaceColor', colors(iS, :));
% end
% 
% yline(0, 'k', 'LineWidth', 1);  % 'k' specifies black color, and LineWidth is the thickness
% 
% % Labels and title
% xlabel('TTE');
% ylabel('Slope of Frequency vs. nBack');
% ylim([-600, 600]);
% title('Slope of Frequency Across TTE');
% grid off;
% hold off;

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% --- FIGURE 6: WM Figure
% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
% Get the number of subjects
nSubjects = numel(cfg.analysisID);
figure; 

% --- First Subpanel: Accuracy by Similarity ---
subplot(4, 3, 1);
hold on;
sgtitle('Figure 3', 'FontSize', 22, 'HorizontalAlignment', 'left', 'FontWeight', 'bold', 'FontName', 'Helvetica Neue');

colors = lines(nSubjects); 
alphaVal = 0.4; 

allDelays = [];
allAccLow = [];
allAccHigh = [];

subjectAccLow = [];
subjectAccHigh = [];

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    subDelays = [];
    subAccLow = [];
    subAccHigh = [];

    for iD = 1:nSessions
        delays = metrics_mt{iS}(iD).conditions_nDistr_delays_wm(:,2);
        accLow = metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm(:,1);
        accHigh = metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm(:,1);

        subDelays = [subDelays; delays];
        subAccLow = [subAccLow; accLow];
        subAccHigh = [subAccHigh; accHigh];

        allDelays = [allDelays; delays];
        allAccLow = [allAccLow; accLow];
        allAccHigh = [allAccHigh; accHigh];

    end

    uniqueDelays = unique(subDelays);
    meanAccLow = NaN(size(uniqueDelays));
    meanAccHigh = NaN(size(uniqueDelays));

    for j = 1:length(uniqueDelays)
        meanAccLow(j) = nanmean(subAccLow(subDelays == uniqueDelays(j)));
        meanAccHigh(j) = nanmean(subAccHigh(subDelays == uniqueDelays(j)));
    end

    subjectAccLow = [subjectAccLow; meanAccLow'];
    subjectAccHigh = [subjectAccHigh; meanAccHigh'];

    plot(uniqueDelays, meanAccLow, '--o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
    plot(uniqueDelays, meanAccHigh, '-o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
end

grandMeanLow = mean(subjectAccLow, 1, 'omitnan');
grandMeanHigh = mean(subjectAccHigh, 1, 'omitnan');

semLow = std(subjectAccLow, 0, 1, 'omitnan') ./ sqrt(nSubjects);
semHigh = std(subjectAccHigh, 0, 1, 'omitnan') ./ sqrt(nSubjects);

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMeanLow - semLow, fliplr(grandMeanLow + semLow)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMeanHigh - semHigh, fliplr(grandMeanHigh + semHigh)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

plot(uniqueDelays, grandMeanLow, '--ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');
plot(uniqueDelays, grandMeanHigh, '-ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');

xlabel('Delay (s)');
ylabel('Accuracy');
set(gca, 'XLim', [0, max(uniqueDelays) + 0.25], 'YLim', [0.3, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
title('A', 'FontSize', 18);

hold off;

% --- Second Subpanel: Accuracy by Number of Distractors ---
subplot(4, 3, 2);
hold on;
sgtitle('Figure 3', 'FontSize', 22, 'HorizontalAlignment', 'left', 'FontWeight', 'bold', 'FontName', 'Helvetica Neue');

colors = lines(nSubjects); 
alphaVal = 0.4; 

allDelays = [];
allAcc2dist = [];
allAcc3dist = [];

subjectAcc2dist = [];
subjectAcc3dist = [];

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    subDelays = [];
    subAcc2dist = [];
    subAcc3dist = [];

    for iD = 1:nSessions
        delays = metrics_mt{iS}(iD).conditions_nDistr_delays_wm(:,2);
        acc2dist = metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm(:,1);  % 2 distractors accuracy
        acc3dist = metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm(:,1);  % 3 distractors accuracy

        subDelays = [subDelays; delays];
        subAcc2dist = [subAcc2dist; acc2dist];
        subAcc3dist = [subAcc3dist; acc3dist];

        allDelays = [allDelays; delays];
        allAcc2dist = [allAcc2dist; acc2dist];
        allAcc3dist = [allAcc3dist; acc3dist];
    end

    uniqueDelays = unique(subDelays);
    meanAcc2dist = NaN(size(uniqueDelays));
    meanAcc3dist = NaN(size(uniqueDelays));

    for j = 1:length(uniqueDelays)
        meanAcc2dist(j) = nanmean(subAcc2dist(subDelays == uniqueDelays(j)));
        meanAcc3dist(j) = nanmean(subAcc3dist(subDelays == uniqueDelays(j)));
    end

    subjectAcc2dist = [subjectAcc2dist; meanAcc2dist'];
    subjectAcc3dist = [subjectAcc3dist; meanAcc3dist'];

    plot(uniqueDelays, meanAcc2dist, '--o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
    plot(uniqueDelays, meanAcc3dist, '-o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
end

grandMean2dist = mean(subjectAcc2dist, 1, 'omitnan');
grandMean3dist = mean(subjectAcc3dist, 1, 'omitnan');

sem2dist = std(subjectAcc2dist, 0, 1, 'omitnan') ./ sqrt(nSubjects);
sem3dist = std(subjectAcc3dist, 0, 1, 'omitnan') ./ sqrt(nSubjects);

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMean2dist - sem2dist, fliplr(grandMean2dist + sem2dist)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMean3dist - sem3dist, fliplr(grandMean3dist + sem3dist)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

plot(uniqueDelays, grandMean2dist, '--ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');
plot(uniqueDelays, grandMean3dist, '-ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');

xlabel('Delay (s)');
ylabel('Accuracy');
set(gca, 'XLim', [0, max(uniqueDelays) + 0.25], 'YLim', [0.3, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
title('B', 'FontSize', 18);

hold off;






% --- Third Subpanel: Accuracy by Presence of Post-Sample Distractor ---
subplot(4, 3, 3);
hold on;

colors = lines(nSubjects);
alphaVal = 0.4;

allDelays = [];
allAccNoPSD = [];
allAccYesPSD = [];

subjectAccNoPSD = [];
subjectAccYesPSD = [];

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    subDelays = [];
    subAccNoPSD = [];
    subAccYesPSD = [];

    for iD = 1:nSessions
        delays = metrics_mt{iS}(iD).conditions_PSD_delays_wm(:,2);
        accNoPSD = metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm(:,1);
        accYesPSD = metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm(:,1);

        subDelays = [subDelays; delays];
        subAccNoPSD = [subAccNoPSD; accNoPSD];
        subAccYesPSD = [subAccYesPSD; accYesPSD];

        allDelays = [allDelays; delays];
        allAccNoPSD = [allAccNoPSD; accNoPSD];
        allAccYesPSD = [allAccYesPSD; accYesPSD];
    end

    uniqueDelays = unique(subDelays);
    meanAccNoPSD = NaN(size(uniqueDelays));
    meanAccYesPSD = NaN(size(uniqueDelays));

    for j = 1:length(uniqueDelays)
        meanAccNoPSD(j) = nanmean(subAccNoPSD(subDelays == uniqueDelays(j)));
        meanAccYesPSD(j) = nanmean(subAccYesPSD(subDelays == uniqueDelays(j)));
    end

    subjectAccNoPSD = [subjectAccNoPSD; meanAccNoPSD'];
    subjectAccYesPSD = [subjectAccYesPSD; meanAccYesPSD'];

    plot(uniqueDelays, meanAccNoPSD, '--o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
    plot(uniqueDelays, meanAccYesPSD, '-o', 'Color', [colors(iS, :) alphaVal], 'LineWidth', 1.5, 'MarkerSize', 3);
end

grandMeanNoPSD = mean(subjectAccNoPSD, 1, 'omitnan');
grandMeanYesPSD = mean(subjectAccYesPSD, 1, 'omitnan');

semNoPSD = std(subjectAccNoPSD, 0, 1, 'omitnan') ./ sqrt(nSubjects);
semYesPSD = std(subjectAccYesPSD, 0, 1, 'omitnan') ./ sqrt(nSubjects);

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMeanNoPSD - semNoPSD, fliplr(grandMeanNoPSD + semNoPSD)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

fill([uniqueDelays; flipud(uniqueDelays)], ...
     [grandMeanYesPSD - semYesPSD, fliplr(grandMeanYesPSD + semYesPSD)], ...
     'k', 'FaceAlpha', 0.2, 'EdgeColor', 'none');

plot(uniqueDelays, grandMeanNoPSD, '--ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');
plot(uniqueDelays, grandMeanYesPSD, '-ok', 'LineWidth', 2.5, 'MarkerSize', 5, 'MarkerFaceColor', 'k');

xlabel('Delay (s)');
ylabel('Accuracy');
set(gca, 'XLim', [0, max(uniqueDelays) + 0.25], 'YLim', [0.3, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
title('C', 'FontSize', 18);

hold off;


% --- Interaction: target distractor similarity
subplot(4, 3, 4);
hold on;

xLow = 1;  % 'Low TDSim' at position 1
xHigh = 2; % 'High TDSim' at position 2
xStar = 0.9; % Position to the left of "Low TDSim" for the star

meanLow = mean(grandMeanLow, 'omitnan');
meanHigh = mean(grandMeanHigh, 'omitnan');
semLow = mean(std(subjectAccLow, 0, 1, 'omitnan') ./ sqrt(nSubjects));
semHigh = mean(std(subjectAccHigh, 0, 1, 'omitnan') ./ sqrt(nSubjects));

for iS = 1:nSubjects
    yLow = subjectAccLow(iS);
    yHigh = subjectAccHigh(iS);
    errLow = std(subjectAccLow(iS)) / sqrt(nSubjects);
    errHigh = std(subjectAccHigh(iS)) / sqrt(nSubjects);
    
    plot([xLow, xHigh], [yLow, yHigh], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yLow + errLow < yHigh - errHigh) || (yLow - errLow > yHigh + errHigh)
        % Plot a star if error bars do not overlap
        plot(xStar, yLow, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot the average line
plot([xLow, xHigh], [meanLow, meanHigh], '-', 'Color', 'k', ...
    'LineWidth', 3);

if (meanLow + semLow < meanHigh - semHigh) || ...
   (meanLow - semLow > meanHigh + semHigh)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanLow, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xLow, xHigh]);
xticklabels({'Low TDSim', 'High TDSim'});
ylabel('Accuracy');
title('D', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
axis padded;

hold off;

% --- Interaction: n distractors
subplot(4, 3, 5);
hold on;

x2Dist = 1;  % '2 Distractors' at position 1
x3Dist = 2;  % '3 Distractors' at position 2
xStar = 0.9; % Position to the left of "2 Distractors" for the star

mean2dist = mean(grandMean2dist, 'omitnan');
mean3dist = mean(grandMean3dist, 'omitnan');
sem2dist = mean(std(subjectAcc2dist, 0, 1, 'omitnan') ./ sqrt(nSubjects));
sem3dist = mean(std(subjectAcc3dist, 0, 1, 'omitnan') ./ sqrt(nSubjects));

% Plot individual lines for each subject
for iS = 1:nSubjects
    y2Dist = subjectAcc2dist(iS);
    y3Dist = subjectAcc3dist(iS);
    err2Dist = std(subjectAcc2dist(iS)) / sqrt(nSubjects);
    err3Dist = std(subjectAcc3dist(iS)) / sqrt(nSubjects);
    
    plot([x2Dist, x3Dist], [y2Dist, y3Dist], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (y2Dist + err2Dist < y3Dist - err3Dist) || (y2Dist - err2Dist > y3Dist + err3Dist)
        % Plot a star if error bars do not overlap
        plot(xStar, y2Dist, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot the average line
plot([x2Dist, x3Dist], [mean2dist, mean3dist], '-', 'Color', 'k', ...
    'LineWidth', 3);

if (mean2dist + sem2dist < mean3dist - sem3dist) || ...
   (mean2dist - sem2dist > mean3dist + sem3dist)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, mean2dist, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([x2Dist, x3Dist]);
xticklabels({'2 Distractors', '3 Distractors'});
ylabel('Accuracy');
title('E', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
axis padded;

hold off;

% --- Interaction: Presence of Post-Sample Distractor ---
subplot(4, 3, 6);
hold on;

xNoPSD = 1;  % 'No PSD' at position 1
xYesPSD = 2; % 'Yes PSD' at position 2
xStar = 0.9; % Position to the left of "No PSD" for the star

meanNoPSD = mean(grandMeanNoPSD, 'omitnan');
meanYesPSD = mean(grandMeanYesPSD, 'omitnan');
semNoPSD = mean(std(subjectAccNoPSD, 0, 1, 'omitnan') ./ sqrt(nSubjects));
semYesPSD = mean(std(subjectAccYesPSD, 0, 1, 'omitnan') ./ sqrt(nSubjects));

% Plot individual lines for each subject
for iS = 1:nSubjects
    yNoPSD = subjectAccNoPSD(iS);
    yYesPSD = subjectAccYesPSD(iS);
    errNoPSD = std(subjectAccNoPSD(iS)) / sqrt(nSubjects);
    errYesPSD = std(subjectAccYesPSD(iS)) / sqrt(nSubjects);
    
    plot([xNoPSD, xYesPSD], [yNoPSD, yYesPSD], '-', 'Color', [colors(iS, :), 0.4], ...
        'LineWidth', 1);
    
    if (yNoPSD + errNoPSD < yYesPSD - errYesPSD) || (yNoPSD - errNoPSD > yYesPSD + errYesPSD)
        % Plot a star if error bars do not overlap
        plot(xStar, yNoPSD, '*', 'Color', colors(iS, :), ...
            'MarkerSize', 4.5, 'LineWidth', 1.5);
    end
end

% Plot the average line
plot([xNoPSD, xYesPSD], [meanNoPSD, meanYesPSD], '-', 'Color', 'k', ...
    'LineWidth', 3);

if (meanNoPSD + semNoPSD < meanYesPSD - semYesPSD) || ...
   (meanNoPSD - semNoPSD > meanYesPSD + semYesPSD)
    % Plot a grey star if average error bars do not overlap
    plot(xStar, meanNoPSD, '*', 'Color', 'k', ...
        'MarkerSize', 6, 'LineWidth', 1.5);
end

xticks([xNoPSD, xYesPSD]);
xticklabels({'No PSD', 'PSD Present'});
ylabel('Accuracy');
title('F', 'FontSize', 18);
set(gca, 'TickLength', [0 0]);
axis padded;

hold off;


% --- SESSIONS PANEL (LOW VS HIGH SIM) WITH BOX PLOTS ---
subplot(4, 3, 7); 
hold on;

title('G', 'FontSize', 18);
xlabel('Session Number');
ylabel('Accuracy');

allAccLow = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 
allAccHigh = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    accLow = NaN(nSessions, 1);
    accHigh = NaN(nSessions, 1);

    for iD = 1:nSessions
        accLow(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm(:,1));
        accHigh(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm(:,1));
    end

    allAccLow(iS, 1:nSessions) = accLow;
    allAccHigh(iS, 1:nSessions) = accHigh;

    plot(1:nSessions, accLow, ':', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    plot(1:nSessions, accHigh, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

% Compute grand mean and SEM
grandMeanLow = nanmean(allAccLow, 1);
grandMeanHigh = nanmean(allAccHigh, 1);
semLow = nanstd(allAccLow, 0, 1) ./ sqrt(nSubjects);
semHigh = nanstd(allAccHigh, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds
xVals = 1:size(allAccLow, 2);
fill([xVals, fliplr(xVals)], [grandMeanLow - semLow, fliplr(grandMeanLow + semLow)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');
fill([xVals, fliplr(xVals)], [grandMeanHigh - semHigh, fliplr(grandMeanHigh + semHigh)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allAccLow, 2), grandMeanLow, '--k', 'LineWidth', 2.5);
plot(1:size(allAccHigh, 2), grandMeanHigh, '-k', 'LineWidth', 2.5);

% Box plot positioning
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    accDataLow = allAccLow(iS, ~isnan(allAccLow(iS, :)));
    accDataHigh = allAccHigh(iS, ~isnan(allAccHigh(iS, :)));

    if ~isempty(accDataLow)
        q1_Low = quantile(accDataLow, 0.25);
        median_Low = median(accDataLow);
        q3_Low = quantile(accDataLow, 0.75);
        min_Low = min(accDataLow);
        max_Low = max(accDataLow);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_Low max_Low], '--', 'Color', colors(iS, :), 'LineWidth', 1.5);
        
        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_Low, q1_Low, q3_Low, q3_Low, q1_Low], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_Low median_Low], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end

    if ~isempty(accDataHigh)
        q1_High = quantile(accDataHigh, 0.25);
        median_High = median(accDataHigh);
        q3_High = quantile(accDataHigh, 0.75);
        min_High = min(accDataHigh);
        max_High = max(accDataHigh);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing + 0.5; 

        % Plot whiskers
        plot([xOffset xOffset], [min_High max_High], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_High, q1_High, q3_High, q3_High, q1_High], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_High median_High], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end


% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [0.25, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);

hold off;


% --- SESSIONS PANEL (2 VS 3 DISTRACTORS) WITH BOX PLOTS ---
subplot(4, 3, 8); 
hold on;

title('H', 'FontSize', 18);
xlabel('Session Number');
ylabel('Accuracy');

allAcc2dist = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 
allAcc3dist = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    acc2dist = NaN(nSessions, 1);
    acc3dist = NaN(nSessions, 1);

    for iD = 1:nSessions
        acc2dist(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm(:,1));
        acc3dist(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm(:,1));
    end

    allAcc2dist(iS, 1:nSessions) = acc2dist;
    allAcc3dist(iS, 1:nSessions) = acc3dist;

    plot(1:nSessions, acc2dist, ':', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    plot(1:nSessions, acc3dist, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

% Compute grand mean and SEM for 2 and 3 distractors
grandMean2dist = nanmean(allAcc2dist, 1);
grandMean3dist = nanmean(allAcc3dist, 1);
sem2dist = nanstd(allAcc2dist, 0, 1) ./ sqrt(nSubjects);
sem3dist = nanstd(allAcc3dist, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds
xVals = 1:size(allAcc2dist, 2);
fill([xVals, fliplr(xVals)], [grandMean2dist - sem2dist, fliplr(grandMean2dist + sem2dist)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');
fill([xVals, fliplr(xVals)], [grandMean3dist - sem3dist, fliplr(grandMean3dist + sem3dist)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allAcc2dist, 2), grandMean2dist, '--k', 'LineWidth', 2.5);
plot(1:size(allAcc3dist, 2), grandMean3dist, '-k', 'LineWidth', 2.5);

% Box plot positioning
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    accData2 = allAcc2dist(iS, ~isnan(allAcc2dist(iS, :)));
    accData3 = allAcc3dist(iS, ~isnan(allAcc3dist(iS, :)));

    if ~isempty(accData2)
        % Compute box plot values
        q1_2 = quantile(accData2, 0.25);
        median_2 = median(accData2);
        q3_2 = quantile(accData2, 0.75);
        min_2 = min(accData2);
        max_2 = max(accData2);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_2 max_2], '--', 'Color', colors(iS, :), 'LineWidth', 1.5);
        
        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_2, q1_2, q3_2, q3_2, q1_2], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_2 median_2], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end

    if ~isempty(accData3)
        % Compute box plot values
        q1_3 = quantile(accData3, 0.25);
        median_3 = median(accData3);
        q3_3 = quantile(accData3, 0.75);
        min_3 = min(accData3);
        max_3 = max(accData3);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing + 0.5; 

        % Plot whiskers
        plot([xOffset xOffset], [min_3 max_3], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_3, q1_3, q3_3, q3_3, q1_3], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_3 median_3], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end


% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [0.25, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);

hold off;


% --- SESSIONS PANEL (NO PSD VS YES PSD) WITH BOX PLOTS ---
subplot(4, 3, 9);
hold on;

title('I', 'FontSize', 18);
xlabel('Session Number');
ylabel('Accuracy');

allAccNoPSD = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 
allAccYesPSD = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    accNoPSD = NaN(nSessions, 1);
    accYesPSD = NaN(nSessions, 1);

    for iD = 1:nSessions
        accNoPSD(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm(:,1));
        accYesPSD(iD) = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm(:,1));
    end

    allAccNoPSD(iS, 1:nSessions) = accNoPSD;
    allAccYesPSD(iS, 1:nSessions) = accYesPSD;

    plot(1:nSessions, accNoPSD, ':', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
    plot(1:nSessions, accYesPSD, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

% Compute grand mean and SEM
grandMeanNoPSD = nanmean(allAccNoPSD, 1);
grandMeanYesPSD = nanmean(allAccYesPSD, 1);
semNoPSD = nanstd(allAccNoPSD, 0, 1) ./ sqrt(nSubjects);
semYesPSD = nanstd(allAccYesPSD, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds
xVals = 1:size(allAccNoPSD, 2);
fill([xVals, fliplr(xVals)], [grandMeanNoPSD - semNoPSD, fliplr(grandMeanNoPSD + semNoPSD)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');
fill([xVals, fliplr(xVals)], [grandMeanYesPSD - semYesPSD, fliplr(grandMeanYesPSD + semYesPSD)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allAccNoPSD, 2), grandMeanNoPSD, '--k', 'LineWidth', 2.5);
plot(1:size(allAccYesPSD, 2), grandMeanYesPSD, '-k', 'LineWidth', 2.5);

% Box plot positioning
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    accDataNoPSD = allAccNoPSD(iS, ~isnan(allAccNoPSD(iS, :)));
    accDataYesPSD = allAccYesPSD(iS, ~isnan(allAccYesPSD(iS, :)));

    if ~isempty(accDataNoPSD)
        q1_NoPSD = quantile(accDataNoPSD, 0.25);
        median_NoPSD = median(accDataNoPSD);
        q3_NoPSD = quantile(accDataNoPSD, 0.75);
        min_NoPSD = min(accDataNoPSD);
        max_NoPSD = max(accDataNoPSD);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_NoPSD max_NoPSD], '--', 'Color', colors(iS, :), 'LineWidth', 1.5);
        
        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_NoPSD, q1_NoPSD, q3_NoPSD, q3_NoPSD, q1_NoPSD], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_NoPSD median_NoPSD], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end

    if ~isempty(accDataYesPSD)
        q1_YesPSD = quantile(accDataYesPSD, 0.25);
        median_YesPSD = median(accDataYesPSD);
        q3_YesPSD = quantile(accDataYesPSD, 0.75);
        min_YesPSD = min(accDataYesPSD);
        max_YesPSD = max(accDataYesPSD);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing + 0.5; 

        % Plot whiskers
        plot([xOffset xOffset], [min_YesPSD max_YesPSD], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_YesPSD, q1_YesPSD, q3_YesPSD, q3_YesPSD, q1_YesPSD], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_YesPSD median_YesPSD], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end

% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [0.25, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);

hold off;





% --- SESSIONS PANEL SIMILARITY (SLOPE PER SESSION) ---
subplot(4, 3, 10); 
hold on;

title('J', 'FontSize', 18);
xlabel('Session Number');
ylabel('Slope (Low vs High Sim)');

allSlopes = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    slopes = NaN(nSessions, 1);

    for iD = 1:nSessions
        accLow = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_LowTDS_wm(:, 1));
        accHigh = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_HighTDS_wm(:, 1));
        
        if ~isnan(accLow) && ~isnan(accHigh)
            slopes(iD) = (accHigh - accLow); % Slope
        else
            slopes(iD) = NaN;
        end
    end

    allSlopes(iS, 1:nSessions) = slopes;

    plot(1:nSessions, slopes, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

% Compute grand mean and SEM for slopes
grandMeanSlopes = nanmean(allSlopes, 1);
semSlopes = nanstd(allSlopes, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds for slopes
xVals = 1:size(allSlopes, 2);
fill([xVals, fliplr(xVals)], [grandMeanSlopes - semSlopes, fliplr(grandMeanSlopes + semSlopes)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allSlopes, 2), grandMeanSlopes, '-k', 'LineWidth', 2.5);

% Box plot positioning for slopes
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    slopeData = allSlopes(iS, ~isnan(allSlopes(iS, :)));

    if ~isempty(slopeData)
        q1_Slope = quantile(slopeData, 0.25);
        median_Slope = median(slopeData);
        q3_Slope = quantile(slopeData, 0.75);
        min_Slope = min(slopeData);
        max_Slope = max(slopeData);

        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_Slope max_Slope], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_Slope, q1_Slope, q3_Slope, q3_Slope, q1_Slope], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_Slope median_Slope], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end

% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [-1,1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

hold off;


% --- SESSIONS PANEL nDISTRACTORS (SLOPE PER SESSION) ---
subplot(4, 3, 11);
hold on;

title('K', 'FontSize', 18);
xlabel('Session Number');
ylabel('Slope (2D vs 3D)');

allSlope = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    slope = NaN(nSessions, 1);

    for iD = 1:nSessions
        acc2Dist = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_2dist_wm(:,1)); % 2-distractor accuracy
        acc3Dist = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_3dist_wm(:,1)); % 3-distractor accuracy
        if ~isnan(acc2Dist) && ~isnan(acc3Dist)
            slope(iD) = (acc3Dist - acc2Dist) / (x3Dist - x2Dist);
        end
    end

    allSlope(iS, 1:nSessions) = slope;

    plot(1:nSessions, slope, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

grandMeanSlope = nanmean(allSlope, 1);
semSlope = nanstd(allSlope, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds
xVals = 1:size(allSlope, 2);
fill([xVals, fliplr(xVals)], [grandMeanSlope - semSlope, fliplr(grandMeanSlope + semSlope)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allSlope, 2), grandMeanSlope, '-k', 'LineWidth', 2.5);

% Box plot positioning
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    slopeData = allSlope(iS, ~isnan(allSlope(iS, :)));

    if ~isempty(slopeData)
        q1_Slope = quantile(slopeData, 0.25);
        median_Slope = median(slopeData);
        q3_Slope = quantile(slopeData, 0.75);
        min_Slope = min(slopeData);
        max_Slope = max(slopeData);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_Slope max_Slope], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);
        
        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_Slope, q1_Slope, q3_Slope, q3_Slope, q1_Slope], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_Slope median_Slope], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end

% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [-1, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

hold off;

% --- SESSIONS PANEL PSD (SLOPE PER SESSION) ---
subplot(4, 3, 12);
hold on;

title('L', 'FontSize', 18);
xlabel('Session Number');
ylabel('Slope (No PSD vs Yes PSD)');

allSlopePSD = NaN(nSubjects, max(cellfun(@(x) length(x), metrics_mt))); 

for iS = 1:nSubjects
    nSessions = length(metrics_mt{iS});
    slopePSD = NaN(nSessions, 1);

    for iD = 1:nSessions
        accNoPSD = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_noPostSampleDist_wm(:,1)); % No PSD accuracy
        accYesPSD = nanmean(metrics_mt{iS}(iD).accuracyMeanSE_yesPostSampleDist_wm(:,1)); % Yes PSD accuracy
        
        if ~isnan(accNoPSD) && ~isnan(accYesPSD)
            slopePSD(iD) = (accYesPSD - accNoPSD) / (xYesPSD - xNoPSD); % Define x-values if applicable
        end
    end

    allSlopePSD(iS, 1:nSessions) = slopePSD;

    plot(1:nSessions, slopePSD, '-', 'Color', [colors(iS, :), 0.4], 'LineWidth', 1.5);
end

% Compute grand mean and SEM
grandMeanSlopePSD = nanmean(allSlopePSD, 1);
semSlopePSD = nanstd(allSlopePSD, 0, 1) ./ sqrt(nSubjects);

% Plot SEM clouds
xVals = 1:size(allSlopePSD, 2);
fill([xVals, fliplr(xVals)], [grandMeanSlopePSD - semSlopePSD, fliplr(grandMeanSlopePSD + semSlopePSD)], ...
    [0.6 0.6 0.6], 'FaceAlpha', 0.4, 'EdgeColor', 'none');

plot(1:size(allSlopePSD, 2), grandMeanSlopePSD, '-k', 'LineWidth', 2.5);

% Box plot positioning
boxXStart = max(cellfun(@(x) length(x), metrics_mt)) + 2; % Position to the right of the line plot
boxSpacing = 1.75; % Space between box plots

for iS = 1:nSubjects
    slopeDataPSD = allSlopePSD(iS, ~isnan(allSlopePSD(iS, :)));

    if ~isempty(slopeDataPSD)
        q1_SlopePSD = quantile(slopeDataPSD, 0.25);
        median_SlopePSD = median(slopeDataPSD);
        q3_SlopePSD = quantile(slopeDataPSD, 0.75);
        min_SlopePSD = min(slopeDataPSD);
        max_SlopePSD = max(slopeDataPSD);
        
        % Positioning
        xOffset = boxXStart + (iS - 1) * boxSpacing;

        % Plot whiskers
        plot([xOffset xOffset], [min_SlopePSD max_SlopePSD], '-', 'Color', colors(iS, :), 'LineWidth', 1.5);
        
        % Plot box (Q1 to Q3)
        plot([xOffset-0.2, xOffset+0.2, xOffset+0.2, xOffset-0.2, xOffset-0.2], ...
             [q1_SlopePSD, q1_SlopePSD, q3_SlopePSD, q3_SlopePSD, q1_SlopePSD], 'Color', colors(iS, :), 'LineWidth', 1.5);

        % Plot median
        plot([xOffset-0.2 xOffset+0.2], [median_SlopePSD median_SlopePSD], 'Color', colors(iS, :), 'LineWidth', 1.5);
    end
end

% Adjust plot limits to accommodate box plots
set(gca, 'XLim', [0, boxXStart + (nSubjects * boxSpacing)], 'YLim', [-1, 1], 'TickDir', 'out');
set(gca, 'TickLength', [0 0]);
yline(0, 'Color', [0.6, 0.6, 0.6], 'LineStyle', '-', 'LineWidth', 1.5);

hold off;

end


disp('end of analyze_multiTask.m'), return

